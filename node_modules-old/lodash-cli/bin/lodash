#!/usr/bin/env node
'use strict';

/** Load Node.js modules. */
var vm = require('vm');

/** Load other modules. */
var _ = require('lodash-compat'),
    listing = require('../lib/listing.js'),
    mapping = require('../lib/mapping.js'),
    minify = require('../lib/minify.js'),
    util = require('../lib/util.js');

/** Module references. */
var createMap = util.createMap,
    fs = util.fs,
    path = util.path;

/** Used as the text displayed for the `--help` option */
var HELP_TEXT = [
  'Usage:',
  '  lodash [commands] [options]',
  '',
  'Commands:',
  '',
  '  compat       Build with support for old & new environments (default)',
  '  modern       Build tailored for newer environments',
  '  strict       Build with ES strict mode enabled',
  '  modularize   Splits lodash into modules',
  '',
  '  include=..   Comma separated function/category names to include in the build',
  '',
  '  minus=..     Comma separated function/category names to remove from the build',
  '',
  '  plus=..      Comma separated function/category names to add to the build',
  '',
  '  category=..  Comma separated categories of functions to include in the build',
  '               (i.e. “array”, “chain”, “collection”, “date”, “function”, “lang”,',
  '               “object”, “number”, “string”, & “utility”)',
  '',
  '  exports=..   Comma separated values of ways to export lodash.',
  '               (i.e. “amd”, “commonjs”, “es”, “global”, “iojs”, “node”, “none”,',
  '               “npm”, & “umd”)',
  '',
  '  iife=..      Code to replace the IIFE that wraps lodash',
  '               (e.g. `lodash iife="!function(){%output%}()"`)',
  '',
  '  template=..  File path pattern used to match template files to precompile',
  '               (e.g. `lodash template=./*.jst`)',
  '',
  '  settings=..  Template settings used when precompiling templates',
  '               (e.g. `lodash settings="{interpolate:/{{([\\s\\S]+?)}}/g}"`)',
  '',
  '  moduleId=..  The AMD module ID used to export lodash in lodash builds or',
  '               the module ID used to include lodash in compiled templates.',
  '',
  '               Use “none” as the module ID to create compiled templates without',
  '               a dependency on lodash.',
  '',
  '  All commands except `compat` & `modern` may be combined.',
  '',
  '  The `exports` values “es” & “npm” may only be used in conjunction with',
  '  the `modularize` command.',
  '',
  '  The `modularize` command uses the first `exports` values as its module format,',
  '  ignoring subsequent values.',
  '',
  '  Unless specified by `-o` or `--output` all files created are saved to the',
  '  current working directory.',
  '',
  'Options:',
  '',
  '  -c, --stdout       Write output to standard output',
  '  -d, --development  Write only the non-minified development output',
  '  -h, --help         Display help information',
  '  -m, --source-map   Generate a source map using an optional source map URL',
  '  -o, --output       Write output to a given path/filename',
  '  -p, --production   Write only the minified production output',
  '  -s, --silent       Skip status updates normally logged to the console',
  '  -V, --version      Output current version of lodash',
  ''
].join('\n');

/** Used to create regexes that detect single and multi-line comment blocks. */
var commentPattern = '(?: *(?:/\\*[^*]*\\*+(?:[^/][^*]*\\*+)*/|\/\/.*)\\n)*';

/** The current working directory. */
var cwd = process.cwd();

/** Used to indicate whether this file is executed directly from Node.js */
var isBin = module == require.main;

/** Native method references. */
var push = Array.prototype.push;

/** Used to match comments and string literals. */
var reComment = /^ *(?:\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\/\/.*)\n/gm,
    reString = /(["'])(?:(?!\1)[^\n\\]|\\.)*?\1/g;

/** Used to detect if a string is a function snippet or a variable declaration snippet. */
var reIsFuncSnippet = /\b(?:function(?:\s+[$\w]+)?|[a-z]+(?:[A-Z][a-z]+)+)\(/,
    reIsVarSnippet = /^\s*var\s+/;

/** Used to match function and string tokens. */
var reCommentToken = /<#com_token\d+#>\n/g,
    reNamedToken = /<<[$\w]+>>\n/g,
    reStringToken = /<#str_token\d+#>/g;

/** Used to determine if a variable search should be deep. */
var reHasDeepVars = /^ *function +runInContext\b/m;

/** Used to detect a function by its JSDoc tags. */
var reHasFuncTags = /^ *\* *(?:@param|@returns|@type +Function)\b/im;

/** Used to match `getCallback` calls and references. */
var reGetCallback = /\bgetCallback\b(?:\(\))?/g;

/** Used to match `toObject` calls. */
var reToObject = /\btoObject\(([^)]+)\)/g;

/** Shortcut to the `stdout` object. */
var stdout = process.stdout;

/*----------------------------------------------------------------------------*/

/**
 * Adds build `commands` to the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Array} [commands=[]] An array of commands.
 * @returns {string} Returns the modified source.
 */
function addCommandsToHeader(source, commands) {
  source = source == null ? '' : String(source);

  return source.replace(getHeader(source), function(header) {
    // Add quotes to commands with spaces or equals signs.
    commands = _.map(commands, function(command) {
      var separator = /[= ]/.exec(command);
      if (separator) {
        separator = separator[0];
        var pair = command.split(separator);
        command = pair[0] + separator + '"' + pair[1] + '"';
      }
      // Escape newlines, carriage returns, multi-line comment end tokens.
      return command
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\*\//g, '*\\/');
    });

    // Remove any existing custom build information.
    header = header
      .replace(' (Custom Build)', '')
      .replace(/^ *\* *Build:.+\n/m, '');

    // Add build commands to copyright/license header.
    return header.replace(/(\/\**\n)( \*)( *@license[\s*]+)?( *lodash [.$\w\-]+)(.*)/, function() {
      return (
        arguments[1] +
        arguments[2] +
        (arguments[3] || '') +
        arguments[4] + ' (Custom Build)' + arguments[5] + '\n' +
        arguments[2] + ' Build: `lodash ' + commands.join(' ') + '`'
      );
    });
  });
}

/**
 * Creates modules based on the provided build state.
 *
 * @private
 * @param {Object} state The build state object.
 * @param {Function} [onComplete] The function called when all module builds
 *  are completed.
 */
function buildModule(state, onComplete) {
  var buildFuncs = state.buildFuncs,
      funcDepMap = state.funcDepMap,
      includeFuncs = state.includeFuncs,
      includeObjs = state.includeObjs,
      includeVars = state.includeVars,
      isAMD = state.isAMD,
      isCommonJS = state.isCommonJS,
      isES = state.isES,
      isNpm = state.isNpm,
      isSilent = state.isSilent,
      minusFuncs = state.minusFuncs,
      objDepMap = state.objDepMap,
      outputPath = state.outputPath,
      plusFuncs = state.plusFuncs,
      stamp = state.stamp,
      varDepMap = state.varDepMap;

  var identifiers = _.without(_.union(buildFuncs, includeObjs, includeVars), 'main'),
      moduleCount = 0,
      removedDeps = {};

  var buildCallback = function(data) {
    moduleCount++;

    var source = data.source;
    source = addCommandsToHeader(source, state.options);
    data.source = cleanupSource(source);
    defaultBuildCallback(data);
  };

  var getUnusedDeps = function(source, depNames) {
    source = cleanupSource(removeStrings(removeComments(source)));
    return _.reject(depNames, function(depName) {
      return RegExp('\\b' + depName + '\\b').test(source);
    });
  };

  var toDepName = !isNpm ? _.identity : function(value) {
    return 'lodash.' + (isPrivate(value) ? '_' : '') + value.toLowerCase();
  };

  if (isNpm) {
    // Load package templates.
    var templatePath = fs.realpathSync(path.join(__dirname, '..', 'template')),
        licenseTemplate = fs.readFileSync(path.join(templatePath, 'license.jst'), 'utf-8'),
        packageTemplate = fs.readFileSync(path.join(templatePath, 'package.jst'), 'utf-8'),
        readmeTemplate = fs.readFileSync(path.join(templatePath, 'readme.jst'), 'utf-8');

    // Exclude "Chain" methods and most internal functions when exporting for npm.
    identifiers = _.reject(_.difference(identifiers, mapping.category.Chain), function(identifier) {
      return isPrivate(identifier) && !_.includes(listing.uninlinables, identifier) && !_.includes(includeFuncs, identifier);
    });

    // Remove unused packages.
    var glob = require('glob'),
        newPackages = _.map(identifiers, toDepName),
        oldPackages = _.map(glob.sync(path.join(outputPath, 'lodash.*')), _.ary(path.basename, 1)),
        unusedPackages = _.difference(oldPackages, newPackages);

    _.each(unusedPackages, function(packageName) {
      var pathname = path.join(outputPath, packageName);
      _.each(fs.readdirSync(pathname), function(identifier) {
        fs.unlinkSync(path.join(pathname, identifier));
      });
      fs.rmdirSync(pathname);
    });
  }
  // List of identifiers that keep their copyright/license headers.
  var includeHeaders = isNpm ? identifiers : _.difference(_.union(includeFuncs, plusFuncs), minusFuncs);
  if (_.isEmpty(includeHeaders)) {
    includeHeaders = ['main'];
  }
  // Create modules for each identifier.
  _.each(identifiers, function(identifier) {
    var category = getCategory(identifier, funcDepMap),
        moduleName = isNpm ? toDepName(identifier) : identifier,
        modulePath = isNpm ? moduleName : getModulePath(identifier, category, funcDepMap);

    var depNames = _.union(
      getDependencies(identifier, funcDepMap),
      getDependencies(identifier, objDepMap),
      getDependencies(identifier, varDepMap)
    ).sort();

    if (isNpm) {
      var hoistDeps = mapping.hoist[identifier],
          forceInlineDeps = _.difference(mapping.forceInline[identifier], hoistDeps),
          uninlinees = _.difference(listing.uninlinables, forceInlineDeps);

      var inlinees = _.uniq(_.transform(_.difference(depNames, uninlinees), function(result, identifier) {
        push.apply(result, getAllDependencies([identifier], funcDepMap, objDepMap, varDepMap, _.clone(uninlinees)));
        return result;
      }));

      depNames = _.union(_.intersection(uninlinees, depNames), _.intersection(uninlinees, inlinees), hoistDeps);
      inlinees = _.difference(inlinees, depNames).concat(identifier);

      var inlineFuncs = _.intersection(listing.funcs, inlinees),
          inlineObjs = _.intersection(listing.objDeps, inlinees),
          inlineVars = _.intersection(listing.varDeps, inlinees);
    }
    else {
      inlinees = [identifier];
      inlineFuncs = _.includes(listing.funcs, identifier) ? inlinees : [];
      inlineObjs = _.includes(listing.objDeps, identifier) ? inlinees : [];
      inlineVars = _.includes(listing.varDeps, identifier) ? inlinees : [];
    }
    state.outputPath = path.join(outputPath, modulePath, (isNpm ? 'index' : identifier) + '.js');
    state.buildFuncs = state.includeFuncs = inlineFuncs;
    state.includeObjs = inlineObjs;
    state.includeVars = inlineVars;

    build(state, function(data) {
      var iife = [],
          source = data.source,
          unusedDeps = _.difference(getUnusedDeps(source, depNames), hoistDeps);

      // Track and remove unused dependencies.
      removedDeps[identifier] = unusedDeps;
      depNames = _.sortBy(_.difference(depNames, unusedDeps), toDepName);

      var depPaths = isNpm
        ? _.map(depNames, toDepName)
        : getDepPaths(depNames, modulePath, funcDepMap);

      if (isAMD) {
        iife.push(
          'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depNames.join(', ') + ') {',
          '%output%',
          '  return ' + identifier + ';',
          '});'
        );
      }
      else if (isES) {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ';\n' : '') +
              'import ' + depName + " from '" + depPath + "'";
          }, '') + ';',
          '%output%',
          'export default ' + identifier + ';'
        );
      }
      else {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ',\n    ' : 'var ') +
              depName + " = require('" + depPath + "')" +
              (isCommonJS ? '.' + depName : '');
          }, '') + ';',
          '%output%',
          (isCommonJS ? 'exports.' + identifier : 'module.exports') + ' = ' + identifier + ';'
        );
      }
      if (!isAMD) {
        source = trimIndent(source);
      }
      source = _.includes(includeHeaders, identifier) ? removeLicenseTag(source) : removeHeader(source);
      source = replaceIIFE(source, iife.join('\n'));

      if (isNpm) {
        var templatePath = fs.realpathSync(path.join(__dirname, '..', 'template')),
            licenseTemplate = fs.readFileSync(path.join(templatePath, 'license.jst'), 'utf-8'),
            packageTemplate = fs.readFileSync(path.join(templatePath, 'package.jst'), 'utf-8'),
            readmeTemplate = fs.readFileSync(path.join(templatePath, 'readme.jst'), 'utf-8');

        var type = 'function',
            version = state.lodash.VERSION;

        if (_.includes(listing.objDeps, identifier)) {
          type = 'object';
        } else if (_.includes(listing.varDeps, identifier)) {
          type = 'variable';
        }
        var templateData = {
          'identifier': identifier,
          'isInternal': isPrivate(identifier),
          'name': moduleName,
          'type': type,
          'version': version,
          'dependencies': _.transform(depPaths, function(result, depPath) {
            var parts = version.split('.');
            result[depPath] = '^' + parts[0] + '.0.0';
          }, {})
        };

        // Independently update the package version.
        if (fs.existsSync(data.outputPath)) {
          var semver = require('semver'),
              laxDeps = _.map(listing.laxSemVerDeps, toDepName),
              oldPackage = require(path.join(path.dirname(data.outputPath), 'package.json')),
              oldVersion = oldPackage.version,
              oldDeps = _.omit(oldPackage.dependencies || {}, laxDeps),
              pkgDeps = _.omit(templateData.dependencies, laxDeps);

          if (_.isEqual(pkgDeps, oldDeps)) {
            var oldSource = fs.readFileSync(data.outputPath, 'utf-8');

            // Exit early if sources are identical.
            if (removeHeader(cleanupSource(oldSource)) === removeHeader(cleanupSource(source))) {
              return;
            }
            // Bump the `patch` version if the source has changed.
            templateData.version = cleanupSource(removeComments(oldSource)) === cleanupSource(removeComments(source))
              ? oldVersion
              : semver.inc(oldVersion, 'patch', true);
          }
          else {
            // Bump the `minor` version if the dependencies have changed.
            templateData.version = semver.inc(oldVersion, 'minor', true);
          }
          var isSameVersion = templateData.version == oldVersion;

          source = source.replace(getHeader(source), function(header) {
            // Use the old header if the package version remains the same.
            header = isSameVersion ? getHeader(oldSource) : header;
            return header.replace(/^( \* *lodash )[.$\w\-]+/m, function(match, prelude) {
              return prelude + templateData.version;
            });
          });
        }
        if (!isSameVersion) {
          fs.writeFileSync(path.join(outputPath, modulePath, 'package.json'), _.template(packageTemplate)(templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'LICENSE.txt'), _.template(licenseTemplate)(templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'README.md'), _.template(readmeTemplate)(templateData), 'utf-8');
        }
      }
      data.source = source;
      buildCallback(data);
    });
  });

  // Add alias modules.
  _.each(identifiers, function(identifier) {
    if (isNpm) {
      return;
    }
    var aliases = getAliases(identifier),
        realCategory = getCategory(identifier, funcDepMap),
        categoryAliases = getCategoryAliases(identifier),
        categories = realCategory ? [realCategory] : [];

    if (!_.isEmpty(categoryAliases)) {
      aliases.push(identifier);
      categories = _.union(categories, categoryAliases);
    }
    if (_.isEmpty(categories)) {
      categories.push(null);
    }
    _.each(categories, function(category) {
      var modulePath = getModulePath(identifier, category, funcDepMap),
          depPath = getDepPath(identifier, modulePath, funcDepMap);

      _.each(aliases, function(alias) {
        if (alias == identifier && category == realCategory) {
          return;
        }
        var iife = [];
        if (isAMD) {
          iife.push(
            'define(["' + depPath + '"], function(' + identifier + ') {',
            '  return ' + identifier + ';',
            '});'
          );
        }
        else if (isES) {
          iife.push(
            'import ' + identifier + " from '" + depPath + "'",
            'export default ' + identifier + ';'
          );
        }
        else {
          iife.push(
            (isCommonJS ? ('exports.' + alias) : 'module.exports') +
            " = require('" + depPath + "')" + (isCommonJS ? '.' + identifier : '') + ';'
          );
        }
        buildCallback({
          'outputPath': path.join(outputPath, modulePath, alias + '.js'),
          'source': iife.join('\n')
        });
      });
    });
  });

  // Create main module.
  (function() {
    var identifier = 'main';
    if (isNpm || !_.includes(buildFuncs, identifier)) {
      return;
    }
    var modulePath = getModulePath(identifier, funcDepMap);

    var categories = _.uniq(_.compact(_.map(identifiers, function(identifier) {
      return getCategory(identifier, funcDepMap);
    }))).sort();

    var categoryDeps = _.map(categories, function(category) {
      return mapping.categoryToDepName[category] || category.toLowerCase();
    });

    var categoryDepPaths = _.map(categories, function(category) {
      return './' + category.toLowerCase();
    });

    var deps = _.union(
      getDependencies(identifier, funcDepMap),
      getDependencies(identifier, objDepMap),
      getDependencies(identifier, varDepMap)
    ).sort();

    var basename = 'index';
    if (isAMD) {
      basename = 'main';
    } else if (isES) {
      basename = 'lodash';
    }
    state.buildFuncs = state.includeFuncs = [identifier];
    state.includeObjs = state.includeVars = [];
    state.outputPath = path.join(outputPath, modulePath, basename + '.js');

    build(state, function(data) {
      var source = data.source;

      // Remove unneeded method and alias assignments.
      _.each(_.difference(listing.funcs, buildFuncs), function(funcName) {
        source = removeMethodAssignment(source, funcName);
      });

      // Wrap `_.mixin`.
      source = source.replace(/^(?: *\/\/.*\n)* *lodash\.[$\w]+\s*=[^;]+;\n/m, function(match) {
        var code = [
          '  // wrap `_.mixin` so it works when provided only one argument',
          '  ' + (isES ? 'var ' : '') + 'mixin = (function(func) {'
        ];

        code.push(
          '    return function(object, source, options) {',
          '      if (options == null) {',
          '        var isObj = isObject(source),',
          '            props = isObj && keys(source),',
          '            methodNames = props && props.length && baseFunctions(source, props);',
          '',
          '        if (!(methodNames ? methodNames.length : isObj)) {',
          '          options = source;',
          '          source = object;',
          '          object = this;',
          '        }',
          '      }',
          '      return func(object, source, options);',
          '    };',
          '  }(' + (isES ? '_' : '') + 'mixin));',
          '',
          match
        );

        return code.join('\n');
      });

      // Add `lodash.support`, `lodash.templateSettings`, and placeholder assignments.
      source = source.replace(/^ *lodash\.VERSION\b.+\n/m, function(match) {
        var code = [
          '',
          '  lodash.support = support;'
        ];

        if (_.includes(identifiers, 'templateSettings')) {
          code.push('  (lodash.templateSettings = ' + mapping.categoryToDepName.String + '.templateSettings).imports._ = lodash;');
        }
        var funcNames = _.intersection(buildFuncs, listing.placeholderFuncs);
        if (!_.isEmpty(funcNames)) {
          code.push(
            '',
            '  // Assign default placeholders.'
          );
          if (_.size(funcNames) > 1) {
            code.push(
              "  arrayEach(['" + funcNames.join("', '") + "'], function(methodName) {",
              '    lodash[methodName].placeholder = lodash;',
              '  });'
            );
          } else {
            code.push('  lodash.' + funcNames[0] + '.placeholder = lodash;');
          }
        }
        code.push('');
        return match + code.join('\n');
      });

      // Add category namespaces to each lodash function assignment.
      source = source.replace(/(lodash(?:\.prototype)?\.[$\w]+\s*=\s*)(?!lodash\b)([$\w]+)/g, function(match, left, identifier) {
        if (_.includes(deps, identifier)) {
          return match;
        }
        var category = mapping.categoryToDepName[getCategory(identifier, funcDepMap)];
        return left + (category ? category + '.' : '') + _.result(mapping.forceAlias, identifier, identifier);
      });

      // Track and remove unused dependencies.
      var unusedDeps = getUnusedDeps(source, deps);
      removedDeps[identifier] = unusedDeps;
      deps = _.difference(deps, unusedDeps);

      var depNames = categoryDeps.concat(deps);
      if (isES) {
        // Avoid a syntax error caused by reassigning `mixin` by naming the
        // dependency `_mixin` instead.
        depNames[_.indexOf(depNames, 'mixin')] = '_mixin';
      }
      var iife = [],
          depArgs = depNames.join(', '),
          depPaths = categoryDepPaths.concat(getDepPaths(deps, modulePath, funcDepMap));

      if (isAMD) {
        iife.push(
          'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depArgs + ') {',
          '%output%',
          '  return lodash;',
          '});'
        );
      }
      else if (isES) {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ';\n' : '') +
              'import ' + depName + " from '" + depPath + "'";
          }, '') + ';',
          '%output%',
          'export default lodash;'
        );
      }
      else {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ',\n    ' : 'var ') +
              depName + " = require('" + depPath + "')" +
              (isCommonJS && !_.includes(categoryDepPaths, depPath) ? '.' + depName : '');
          }, '') + ';',
          '%output%',
          (isCommonJS ? 'exports._' : 'module.exports') + ' = lodash;'
        );
      }
      if (!isAMD) {
        source = trimIndent(source);
      }
      if (!_.includes(includeHeaders, identifier)) {
        source = removeHeader(source);
      }
      source = replaceIIFE(source, iife.join('\n'));

      data.source = source;
      buildCallback(data);
    });
  }());

  // Create category modules.
  _.each(_.uniq(_.compact(_.flatten(_.map(identifiers, _.partial(getCategory, _, funcDepMap))))), function(category) {
    if (isNpm) {
      return;
    }
    var depNames = _.transform(_.intersection(getNamesByCategory(category), identifiers), function(result, depName) {
      if (!mapping.forceAlias[depName]) {
        result.push(depName);
      }
      push.apply(result, getAliases(depName));
    })
    .sort();

    var iife = [],
        depPaths = getDepPaths(depNames, null, funcDepMap);

    if (isAMD) {
      iife.push(
        "define(['" + depPaths.join("', '") + "'], function(" + depNames.join(', ') + ') {',
        '  return {',
        _.map(depNames, function(depName) {
          return "    '" + depName + "': " + depName;
        })
        .join(',\n'),
        '  };',
        '});'
      );
    }
    else {
      if (isES) {
        push.apply(iife,
          _.map(depNames, function(depName, index) {
            return 'import ' + depName + " from '" + depPaths[index] + "';";
          })
        );

        iife.push(
          '',
          'export default {',
          _.map(depNames, function(depName) {
            return "  '" + depName + "': " + depName;
          })
          .join(',\n'),
          '};'
        );
      }
      else if (isCommonJS) {
        push.apply(iife,
          _.map(depNames, function(depName) {
            var depPath = depPaths[_.indexOf(depNames, depName)];
            return 'exports.' + depName + " = require('" + depPath + "')." + depName + ';';
          })
        );
      }
      else {
        iife.push(
          'module.exports = {',
          _.map(depNames, function(depName) {
            var depPath = depPaths[_.indexOf(depNames, depName)];
            return "  '" + depName + "': require('" + depPath + "')";
          })
          .join(',\n'),
          '};'
        );
      }
    }
    buildCallback({
      'outputPath': path.join(outputPath, category.toLowerCase() + '.js'),
      'source': iife.join('\n')
    });
  });

  if (!isSilent) {
    // Warn of removed dependencies.
    _.forOwn(removedDeps, function(depNames, identifier) {
      if (!_.isEmpty(depNames)) {
        var plural = _.size(depNames) > 1;
        console.warn('Warning: Removed ' + (plural ? '' : 'an ') + 'unused dependenc' + (plural ? 'ies' : 'y') + ' from `' + identifier + '`: ' + depNames.join(', '));
      }
    });

    console.log('Created %d modules in %d seconds.', moduleCount, (_.now() - stamp) / 1000);
  }
  if (onComplete) {
    onComplete({ 'outputPath': fs.realpathSync(outputPath) });
  }

}

/**
 * Compiles template files based on the provided build state extending
 * `_.templates` with precompiled templates named after each file's basename.
 *
 * @private
 * @param {Object} state The build state object.
 * @returns {string} Returns the compiled source.
 */
function buildTemplate(state) {
  var moduleId = state.moduleId || 'lodash',
      isStandalone = moduleId == 'none',
      pattern = state.templatePattern,
      settings = state.templateSettings;

  pattern = path.normalize(pattern || path.join(cwd, '*.jst'));

  var hr = '  /*----------------------------------------------------------------------------*/';

  var source = [
    ';(function() {',
    '  var undefined;',
    '',
    '  var objectTypes = {',
    "    'function': true,",
    "    'object': true",
    '  };',
    '',
    '  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;',
    '',
    '  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;',
    '',
    "  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;",
    '',
    '  var freeSelf = objectTypes[typeof self] && self && self.Object && self;',
    '',
    '  var freeWindow = objectTypes[typeof window] && window && window.Object && window;',
    '',
    '  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;',
    '',
    '  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;',
    ''
  ];

  if (isStandalone) {
    build(['exports=none', 'include=escape', 'iife=%output%', '-d', '-s'], function(data) {
      var escapeSource = data.source;
      escapeSource = removeHeader(escapeSource);
      escapeSource = removeFunction(escapeSource, 'lodash');
      escapeSource = removeAssignments(escapeSource);
      escapeSource = cleanupSource(escapeSource);

      source.push(
        '',
        escapeSource,
        '',
        "  var _ = { 'escape': escape };",
        ''
      );
    });
  }
  else {
    source.push(
      '  var _ = root._ || {};',
      ''
    );
  }
  source.push(
    hr,
    ''
  );

  var glob = require('glob'),
      dirname = path.dirname(pattern),
      filePaths = glob.sync(pattern);

  if (dirname == '.') {
    dirname = '';
  }
  var basePath = (dirname + path.sep).replace(RegExp('(^|' + path.sepEscaped + ')\\*\\*.*$'), '$1'),
      insertAt = source.length,
      templates = createMap();

  _.each(filePaths, function(filePath) {
    var string = fs.readFileSync(filePath, 'utf8'),
        precompiled = cleanupCompiled(getFunctionSource(_.template(string, settings), 2));

    // Glob uses *nix path separators even on Windows.
    // See https://github.com/isaacs/node-glob#windows.
    var clipped = filePath.slice(dirname ? basePath.length : 0).replace(/\..*$/, ''),
        props = clipped.split('/');

    // Create namespace objects.
    _.reduce(props, function(object, key) {
      return object[key] || (object[key] = createMap());
    }, templates);

    // Escape namespace property names.
    props = _.map(props, function(key) {
      return "['" + key.replace(/['\n\r\t]/g, '\\$&') + "']";
    });

    // Add template assignment to `source`.
    source.push('  templates' + props.join('') + ' = ' + precompiled + ';', '');
  });

  // Add the initial `_.templates` object to `source`.
  source.splice(insertAt, 0, '  var templates = ' +
    JSON.stringify(templates, null, 4)
      .replace(/^ *\}$/m, '  $&')
      .replace(/'/g, "\\'")
      .replace(/([^\\])"/g, "$1'") +
    ';',
    ''
  );

  source.push(
    hr,
    '',
    "  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {"
  );

  if (isStandalone) {
    source.push(
      '    define(function() {',
      '      return templates;'
    );
  }
  else {
    source.push(
      "    define(['" + moduleId + "'], function(lodash) {",
      '      _ = lodash;',
      '      lodash.templates = lodash.extend(lodash.templates || {}, templates);'
    );
  }
  source.push(
    '    });',
    '  }',
    '  else if (freeExports && freeModule) {'
  );

  if (!isStandalone) {
    source.push("    _ = require('" + moduleId + "');");
  }
  source.push(
    '    if (moduleExports) {',
    '      (freeModule.exports = templates).templates = templates;',
    '    } else {',
    '      freeExports.templates = templates;',
    '    }'
  );

  if (isStandalone) {
    source.push(
      '  }',
      '  else {',
      '    root.templates = templates;',
      '  }'
    );
  }
  else {
    source.push(
      '  }',
      '  else if (_) {',
      '    _.templates = _.extend(_.templates || {}, templates);',
      '  }'
    );
  }
  source.push('}.call(this));');
  return source.join('\n');
}

/**
 * Removes unnecessary semicolons and whitespace from compiled code.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupCompiled(source) {
  return stringFree(source, function(source) {
    return source
      .replace(/\b(function)\s*(\()/g, '$1$2')
      .replace(/([{}])\s*;/g, '$1');
  });
}

/**
 * Removes unnecessary comments, and whitespace.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupSource(source) {
  return stringFree(source, function(source) {
    return source
      // Consolidate consecutive horizontal rule comment separators.
      .replace(/(?:\s*\/\*-+\*\/\s*){2,}/g, function(separators) {
        var indent = /^\s*/.exec(separators)[0];
        return indent + separators.slice(separators.lastIndexOf('/*'));
      })
      // Remove unneeded single line comments.
      .replace(/(\{\s*)?(\n *\/\/.*)(\s*\})/g, function(match, prelude, comment, postlude) {
        return (!prelude && postlude) ? postlude : match;
      })
      // Remove unattached multi-line and single line comments.
      .replace(/^ *(?:\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\/\/.*)\n\n/gm, '\n')
      // Remove unneeded horizontal rule comment separators.
      .replace(/(\{\s*\n) *\/\*-+\*\/\n|^ *\/\*-+\*\/\n(\s*\})/gm, '$1$2')
      // Remove trailing horizontal rule comment separators.
      .replace(/\s*\/\*-+\*\/\s*$/, '')
      // Remove lines with just spaces and semicolons.
      .replace(/^ *;\n/gm, '')
      // Remove trailing spaces from lines.
      .replace(/ *$/gm, '')
      // Consolidate multiple newlines.
      .replace(/\n{3,}/g, '\n\n')
      // Remove leading empty lines.
      .replace(/^ *\n+/, '')
      // Add trailing newline.
      .trimRight() + '\n';
  });
}

/**
 * Invokes `callback` providing `source` with comments removed and returns the
 * modified source with comments restored.
 *
 * @private
 * @param {string} source The source to modify.
 * @param {Function} [callback] The function to modify the comment free source.
 * @returns {string} Returns the modified source.
 */
function commentFree(source, callback) {
  var comments = [];
  source = source == null ? '' : String(source);
  source = callback(source.replace(reComment, function(match) {
    var index = comments.length;
    comments.push(match);
    return '<#com_token' + index + '#>\n';
  })) || '';

  source = source == null ? '' : String(source);
  return source.replace(reCommentToken, function(match) {
    return comments[match.slice(11, -3)];
  });
}

/**
 * The default callback used for `build` invocations.
 *
 * @private
 * @param {Object} data The data for the given build.
 *  gzip - The gzipped output of the built source
 *  outputPath - The path where the built source is to be written
 *  source - The built source output
 *  sourceMap - The source map output
 */
function defaultBuildCallback(data) {
  var outputPath = data.outputPath,
      sourceMap = data.sourceMap;

  if (outputPath) {
    fs.writeFileSync(outputPath, data.source, 'utf8');
    if (sourceMap) {
      fs.writeFileSync(path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.map'), sourceMap, 'utf8');
    }
  }
}

/**
 * Gets the aliases associated with a given identifier.
 *
 * @private
 * @param {string} identifier The identifier to get aliases for.
 * @returns {Array} Returns an array of aliases.
 */
function getAliases(identifier) {
  return _.result(mapping.realToAlias, identifier, []);
}

/**
 * Gets the category aliases associated with a given identifier.
 *
 * @private
 * @param {string} identifier The identifier to get category aliases for.
 * @returns {Array} Returns an array of aliases.
 */
function getCategoryAliases(identifier) {
  return _.transform(mapping.aliasCategory, function(result, identifiers, category) {
    if (_.includes(identifiers, identifier)) {
      result.push(category);
    }
  }, []);
}

/**
 * Creates an array of all function, object, and variable dependencies for the
 * given identifier(s).
 *
 * @private
 * @param {string|string[]} identifier The identifier or array of identifiers to query.
 * @param {Object} funcDepMap The dependency map to look up function dependencies.
 * @param {Object} objDepMap The dependency map to look up object dependencies.
 * @param {Object} varDepMap The dependency map to look up variable dependencies.
 * @param- {Array} [stackA=[]] Internally used track queried identifiers.
 * @returns {Array} Returns an array of identifier dependencies.
 */
function getAllDependencies(identifier, funcDepMap, objDepMap, varDepMap, stack) {
  var result = identifier;
  if (!_.isArray(stack)) {
    result = _.isArray(identifier) ? _.clone(identifier) : [identifier];
    stack = [];
  }
  _.each(result, function(identifier) {
    if (!_.includes(stack, identifier)) {
      push.apply(result, getDependencies(identifier, funcDepMap));
      push.apply(result, getDependencies(identifier, objDepMap));
      push.apply(result, getDependencies(identifier, varDepMap));
      stack.push(identifier);
      getAllDependencies(result, funcDepMap, objDepMap, varDepMap, stack);
    }
  });
  return stack ? result : _.uniq(result);
}

/**
 * Gets the category of the given identifier.
 *
 * @private
 * @param {string} identifier The identifier to query.
 * @param {Object} [funcDepMap] The dependency map used to resolve the identifier.
 * @returns {string|undefined} Returns the category.
 */
function getCategory(identifier, funcDepMap) {
  identifier = getRealName(identifier);
  return _.find(listing.categories, function(category) {
    return _.includes(mapping.category[category], identifier);
  });
}

/**
 * Gets the `bufferClone` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getBufferCloneFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(!bufferSlice\b[\s\S]+?\n\1  bufferClone\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Resolves the path of the given module dependency. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {string} depName The name of the dependency.
 * @param {string} [fromPath=''] The path to resolve the dependency relative to.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the dependency path.
 */
function getDepPath(depName, fromPath, funcDepMap) {
  var sep = '/',
      toPath = getModulePath(depName, funcDepMap),
      relative = path.relative(fromPath || '', toPath).replace(RegExp(path.sepEscaped, 'g'), sep);

  if (relative.charAt(0) != '.') {
    relative = '.' + (relative ? sep + relative : '');
  }
  return relative + sep + depName;
}

/**
 * Resolves the paths of the given module dependencies. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {Array} depNames The array dependency names.
 * @param {string} [fromPath=''] The path to resolve dependencies relative to.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string[]} Returns the dependency paths.
 */
function getDepPaths(depNames, fromPath, funcDepMap) {
  return _.map(depNames, function(depName) {
    return getDepPath(depName, fromPath, funcDepMap);
  });
}

/**
 * Creates an array of depenants for the given identifier(s).
 *
 * @private
 * @param {string} identifier The identifier or array of identifiers to query.
 * @param {Object} depMap The dependency map to look up dependants.
 * @param {boolean} [isDeep=false] A flag to specify retrieving nested dependants.
 * @param- {Array} [stackA=[]] Internally used track queried identifiers.
 * @returns {Array} Returns an array of identifier dependants.
 */
function getDependants(identifier, depMap, isDeep, stack) {
  var identifiers = _.isArray(identifier) ? identifier : [identifier];
  stack || (stack = []);

  // Iterate over the dependency map, adding names of functions that have `identifier` as a dependency.
  return _.uniq(_.transform(depMap, function(result, depNames, otherName) {
    if (!_.includes(stack, otherName) &&
        _.some(identifiers, _.partial(_.includes, depNames, _, 0))) {
      result.push(otherName);
      if (isDeep) {
        stack.push(otherName);
        push.apply(result, getDependants(otherName, depMap, isDeep, stack));
      }
    }
  }, []));
}

/**
 * Creates an array of dependencies for the given identifier(s).
 *
 * @private
 * @param {string|string[]} identifier The identifier or array of identifiers to query.
 * @param {Object} depMap The dependency map to look up dependencies.
 * @param {boolean} [isDeep=false] A flag to specify retrieving nested dependencies.
 * @param- {Array} [stackA=[]] Internally used track queried identifiers.
 * @returns {Array} Returns an array of identifier dependencies.
 */
function getDependencies(identifier, depMap, isDeep, stack) {
  var depNames = _.isArray(identifier) ? identifier : depMap[identifier];
  if (!isDeep) {
    return depNames ? _.difference(depNames, stack) : [];
  }
  stack || (stack = []);

  // Recursively accumulate the dependencies of the `identifier` function,
  // the dependencies of its dependencies, and so on.
  return _.uniq(_.transform(depNames, function(result, otherName) {
    if (!_.includes(stack, otherName)) {
      stack.push(otherName);
      result.push(otherName);
      push.apply(result, getDependencies(otherName, depMap, isDeep, stack));
    }
  }));
}

/**
 * Gets the formatted source of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @param {number|string} [indent=0] The level to indent.
 * @returns {string} Returns the formatted source.
 */
function getFunctionSource(func, indent) {
  var source = String(func.source || func),
      srcIndent = getIndent(source),
      forceIndent = _.size(source.match(RegExp('^' + srcIndent + '}', 'gm'))) > 1;

  indent || (indent = '');
  if (typeof indent == 'number') {
    indent = _.repeat(' ', indent);
  }
  // Remove any existing indent.
  if (srcIndent) {
    source = source.replace(RegExp('^' + srcIndent, 'gm'), '');
  }
  // Set indent of source.
  return indent + source.replace(/\n(?:.*)/g, function(match, index) {
    var prelude = '\n' + indent;
    match = match.slice(1);
    if (forceIndent) {
      prelude += (match == '}' && !_.includes(source, '}', index + 2) ? '' : '  ');
    }
    return prelude + match;
  });
}


/**
 * Gets the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the copyright/license header.
 */
function getHeader(source) {
  source = source == null ? '' : String(source);
  return _.result(/^(?:\s*\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\s*\/\/.*)*\n/.exec(source), 0, '');
}

/**
 * Gets the indent of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the indent.
 */
function getIndent(func) {
  return /^ *(?=\S)/m.exec(func.source || func)[0];
}

/**
 * Gets the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArgumentsFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\((?:!support\.argsTag|!isArguments)\b[\s\S]+?\n\1  isArguments\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArrayFork(source) {
  return matchFunction(source, 'isArray')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsElementFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(!support\.dom\b[\s\S]+?\n\1  isElement\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsFunctionFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(isFunction\(\/x\/[\s\S]+?\n\1  isFunction\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the lodash method assignments snippet from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the method assignments snippet.
 */
function getMethodAssignments(source) {
  return _.result(/\n\n(?: *\/\/.*\n)* *lodash(?:\.(?!prototype\b)[$\w]+)+\s*=[\s\S]+\n *lodash(?:\.[$\w]+)+\s=[^;]+;(?=\n)/.exec(source), 0, '');
}

/**
 * Resolves the module path of the given identifier.
 *
 * @private
 * @param {string} identifier The module identifier.
 * @param {string} [category] The category of the identifier.
 * @param {Object} [funcDepMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the module path.
 */
function getModulePath(identifier, category, funcDepMap) {
  if (_.includes(listing.topLevelDeps, identifier)) {
    return '';
  }
  if (isPrivate(identifier)) {
    return 'internal';
  }
  if (_.isObject(category)) {
    funcDepMap = category;
    category = null;
  }
  if (category == null) {
    category = getCategory(identifier, funcDepMap);
  }
  return category.toLowerCase();
}

/**
 * Gets the names of identifiers in `source` that belong to the given category.
 *
 * @private
 * @param {string} category The category to filter by.
 * @returns {Array} Returns a new array of names.
 */
function getNamesByCategory(category) {
  return _.union(mapping.category[category], mapping.aliasCategory[category]);
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getNowFork(source) {
  return matchFunction(source, 'now')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the value of a given name from the `options` array. If no value is
 * available the `defaultValue` is returned.
 *
 * @private
 * @param {Array} options The options array to inspect.
 * @param {string} name The name of the option.
 * @param {*} defaultValue The default option value.
 * @returns {*} Returns the option value.
 */
function getOption(options, name, defaultValue) {
  var isArr = _.isArray(defaultValue);
  return _.reduce(options, function(result, value) {
    if (isArr) {
      value = optionToArray(name, value);
      return _.isEmpty(value) ? result : value;
    }
    value = optionToValue(name, value);
    return value == null ? result : value;
  }, defaultValue);
}

/**
 * Gets the `_.parseInt` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getParseIntFork(source) {
  return _.result(/^(?: *\/\/.*\n)*( *)if\s*\(nativeParseInt\(whitespace\b[\s\S]+?\n\1  parseInt\s*=[\s\S]+?\n\1\}\n/m.exec(source), 0, '');
}

/**
 * Gets the real name of `alias`.
 *
 * @private
 * @param {string} alias The alias to resolve.
 * @returns {string} Returns the real name.
 */
function getRealName(alias) {
  return _.result(mapping.aliasToReal, alias, alias);
}

/**
 * Gets the real category of `alias`.
 *
 * @private
 * @param {string} alias The alias to resolve.
 * @returns {string} Returns the real category.
 */
function getRealCategory(alias) {
  return _.result(mapping.oldCategory, alias, alias);
}

/**
 * Creates an array variables names from all variables defined outside of
 * lodash functions.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {Array} Returns a new array of variable names.
 */
function getVars(source) {
  var isDeep = reHasDeepVars.test(source),
      indentA = isDeep ? ' {2,4}' : ' {2}',
      indentB = isDeep ? ' {6,8}' : ' {6}';

  var reAttempts = [
    // Match a varaible at the start of a declaration list.
    ['^(' + indentA + 'var\\s+)([$\\w]+)\\s*=.+?,\\n *', 2, 1],
    // Match a variable declaration in a declaration list.
    [',\\n' + commentPattern + indentB + '([$\\w]+)\\s*=[\\s\\S]+?(?=[,;]\\n)', 1, -1],
    // Match a variable that is not part of a declaration list.
    ['^(' + indentA + ')var\\s+([$\\w]+)\\s*(?:|=\\s*(?:.+?(?:[&+]\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1\\S+?));\\n', 2, -1]
  ];

  source = removeStrings(removeComments(source));
  return _.uniq(_.transform(reAttempts, function(result, data) {
    source = source.replace(RegExp(data[0], 'gm'), function() {
      result.push(arguments[data[1]]);
      return data[2] > -1 ? arguments[data[2]] : '';
    });
  }));
}

/**
 * Checks if `source` is a function snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {boolean} Returns `true` for a function snippet, else `false`.
 */
function isFunctionSnippet(source) {
  source = source == null ? '' : String(source);
  var header = getHeader(source);
  return (header && reHasFuncTags.test(header)) || reIsFuncSnippet.test(source.replace(header, ''));
}

/**
 * Checks if `identifier` is private.
 *
 * @private
 * @param {string} identifier The identifier to query.
 * @returns {boolean} Returns `true` if the identifier is private, else `false`.
 */
function isPrivate(identifier) {
  identifier = getRealName(identifier);
  if (_.includes(listing.topLevelDeps, identifier)) {
    return false;
  }
  return _.findKey(mapping.category, function(identifiers) {
    return _.includes(identifiers, identifier);
  }) === undefined;
}

/**
 * Checks if the variable `varName` is used in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable.
 * @returns {boolean} Returns `true` if the variable is used, else `false`.
 */
function isVarUsed(source, varName) {
  source = source == null ? '' : String(source);
  var snippet = matchVar(source, varName);
  if (!snippet) {
    return false;
  }
  // Remove the variable assignment from the source.
  source = source.replace(snippet, '');
  return RegExp('[^.$"\'\\w]' + _.escapeRegExp(varName) + '\\b(?!\\s*=)').test(source);
}

/**
 * Searches `source` for a `funcName` function declaration, expression, or
 * assignment and returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} funcName The name of the function to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched function snippet.
 */
function matchFunction(source, funcName, leadingComments) {
  funcName = _.escapeRegExp(funcName);

  var reAttempts = [
    // Match a function declaration.
    '( *)function\\s+' + funcName + '\\((?:\\)\\s*\\{\\s*|[\\s\\S]+?\\n\\3)\\}\\n',
    // Match a simple variable declaration.
    ' *var\\s+' + funcName + '\\s*=.+?;\\n',
    // Match variable declarations using creator functions.
    '( *)var\\s+' + funcName + '\\s*=.*?(?:create|rest)(?:[A-Z][a-z]+)+\\((?:.+|[\\s\\S]+?\\n\\3(?:\\S.*?)?)\\);\\n',
    // Match a variable declaration with function expression.
    '( *)var\\s+' + funcName + '\\s*=.*?function\\([\\s\\S]+?\\{\\n[\\s\\S]+?\\n\\3\\}(?:\\(\\)\\))?;\\n'
  ];

  return _.reduce(reAttempts, function(result, reSource, index) {
    if (result) {
      return result;
    }
    result = RegExp('^(' + commentPattern + ')(' + reSource + ')', 'm').exec(source);
    return (result && isFunctionSnippet(result)) ? result[leadingComments ? 0 : 2] : '';
  }, '');
}

/**
 * Searches `source` for a lodash property, of the given property name, and
 * returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} propName The name of the property to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched property snippet.
 */
function matchProp(source, propName, leadingComments) {
  propName = _.escapeRegExp(propName);

  return _.result(RegExp(
    '^' + (leadingComments ? commentPattern : '') +
    '(?: {2,4}var\\s+' + propName + '\\b.+|(?:\\s*|.*?=\\s*)lodash\\._?' + propName + '\\s*)=[\\s\\S]+?' +
    '(?:\\(function\\([\\s\\S]+?\\}\\([^)]*\\)\\);\\n(?=\\n)|' +
    '[;}]\\n(?=\\n(?!\\s*\\(function\\b)))'
  , 'm').exec(source), 0, '');
}

/**
 * Searches `source` for a `varName` variable assignment and returns
 * the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched variable snippet.
 */
function matchVar(source, varName, leadingComments) {
  varName = _.escapeRegExp(varName);

  var reAttempts = [
    // Match a varaible at the start of a declaration list.
    ['^( *var\\s+)(' + varName + '\\s*=.+?,\\n *)', 2, 2],
    // Match a variable declaration in a declaration list.
    ['(,\\n' + commentPattern + ')( *' + varName + '\\s*=[\\s\\S]+?(?=[,;]\\n))', 2, 0],
    // Match a variable that is not part of a declaration list.
    ['^(' + commentPattern + ')(( *)var\\s+' + varName + '\\s*(?:|=\\s*(?:.+?(?:[&+]\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\3\\S+?));\\n)', 2, 0]
  ];

  // Match complex variable assignments.
  if (_.includes(listing.complexVars, varName)) {
    reAttempts.splice(2, 0, ['^(' + commentPattern + ')(( *)var\\s+' + varName + '\\s*=[\\s\\S]+?[};]\\n(?=\\s*\\n(?:\\S|\\3(?:function\\b|if\\b|lodash\\b|var\\s|/[/*]))))', 2, 0]);
  }
  return _.reduce(reAttempts, function(result, data) {
    return result || _.result(RegExp(data[0], 'm').exec(source), data[leadingComments ? 2 : 1], '');
  }, '');
}

/**
 * Converts a comma separated option value into an array.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {Array} Returns the new converted array.
 */
function optionToArray(name, string) {
  return _.compact(_.invoke((optionToValue(name, string) || '').split(/, */), 'trim'));
}

/**
 * Extracts the option value from an option string.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {string|undefined} Returns the option value, else `undefined`.
 */
function optionToValue(name, string) {
  var result = RegExp('^' + _.escapeRegExp(name) + '(?:=([\\s\\S]+))?$').exec(string);

  if (result) {
    result = _.result(result, 1);
    result = result ? _.trim(result) : true;
  }
  if (result === 'false') {
    return false;
  }
  return result || undefined;
}

/**
 * Removes all lodash method and property assignments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeAssignments(source) {
  // Remove method and intermediate assignments.
  source = removeMethodAssignments(source);
  return source.replace(/(=\s*)lodash\.[$\w]+\s*=\s*/g, '$1');
}

/**
 * Removes the `bufferClone` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeBufferCloneFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getBufferCloneFork(source), '');
}

/**
 * Removes support for lodash wrapper chaining in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeChaining(source) {
  source = removeLazyChaining(source);
  source = removeMixinCalls(source);
  source = removeSpliceObjectsFix(source);

  // Remove all `lodash.prototype` additions.
  return source
    .replace(/^(?: *\/\/.*\n)*( *)arrayEach\(\['concat\b[\s\S]+?\n\1\}\);\n/m, '')
    .replace(/^(?: *\/\/.*\n)*( *)lodash\.prototype\.(?!constructor\b)[$\w]+\s*=\s*(?:function\([\s\S]+?\n\1\}|.+?);\n/gm, '');
}

/**
 * Removes all comments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeComments(source) {
  source = source == null ? '' : String(source);
  return source.replace(reComment, '');
}

/**
 * Removes support for lazy chaining in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeLazyChaining(source) {
  // Remove bulk `LazyWrapper.prototype` assignments.
  source = source.replace(/^(?: *\/\/.*\n)*( *)arrayEach\(\['(?:drop|dropWhile|first|initial|pluck)\b[\s\S]+?\n\1\}\);\n/gm, '');

  // Remove `LazyWrapper` methods `compact`, `reject`, `slice`, and `toArray` assignments.
  source = source.replace(/^(?: *\/\/.*\n)*( *)LazyWrapper\.prototype\.(?:compact|reject|slice|toArray)\s*=[\s\S]+?\n\1\};\n/gm, '');

  // Remove other `LazyWrapper.prototype` assignments.
  source = source.replace(/^(?: *\/\/.*\n)* *LazyWrapper\.prototype\.(?!constructor\b)[$\w]+\s*=[^;]+;\n/gm, '');

  // Remove `LazyWrapper` additions to `LodashWrapper` and `realNames` assignments.
  source = source.replace(/^(?: *\/\/.*\n)*( *)baseForOwn\(LazyWrapper\.prototype\b[\s\S]+?\n\1\}\);\n/gm, '');

  // Remove `realNames` assignment for `wrapper`.
  source = source.replace(/^(?: *\/\/.*\n)* *realNames\[createHybridWrapper\b[\s\S]+?;\n/m, '');

  // Remove related `lodash.prototype` method aliases.
  return source.replace(/^(?: *\/\/.*\n)* *lodash\.prototype\.(?:collect|head|select|tail)\s*=[^;]+;\n/gm, '');
}

/**
 * Removes metadata optimizations from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @param {Object} [varDepMap] The variable dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeMetadata(source, funcDepMap, objDepMap, varDepMap) {
  var deps = _.result(funcDepMap, 'createWrapper', []);
  _.pull(deps, 'baseSetData', 'getData', 'mergeData', 'setData');

  deps = _.result(funcDepMap, 'createHybridWrapper', []);
  _.pull(deps, 'isLaziable', 'setData');

  deps = _.result(funcDepMap, 'support', []);
  _.pull(deps, 'isNative');

  deps = _.result(varDepMap, 'support', []);
  _.pull(deps, 'root');

  source = removeSupportProp(source, 'funcDecomp');
  source = removeSupportProp(source, 'funcNames');

  // Remove metadata related code.
  source = source.replace(matchFunction(source, 'createWrapper'), function(match) {
    match = _.reduce(['data', 'funcBitmask', 'funcIsPartialed', 'setter'], removeVar, match);
    return match
      .replace(/^(?: *\/\/.*\n)*( *)if\s*\((?:typeof\s+)?data\b[\s\S]+?\n\1\}\n/gm, '')
      .replace(/^( *return\s+)setter\(([^,]+),[^)]+\)/m, '$1$2');
  });

  source = source.replace(matchFunction(source, 'createHybridWrapper'), function(match) {
    match = removeVar(match, 'newData');
    match = replaceVar(match, 'result', 'createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity)');
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(isLaziable\b[\s\S]+?\n\1\}\n/m, '');
  });

  return source;
}

/**
 * Removes the `funcName` function declaration, expression, or assignment and
 * associated code from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to remove.
 * @returns {string} Returns the modified source.
 */
function removeFunction(source, funcName) {
  source = source == null ? '' : String(source);
  return (funcName == 'runInContext')
    ? removeRunInContext(source, funcName)
    : source.replace(matchFunction(source, funcName, true), '');
}

/**
 * Removes all references to `getGetCallback` from `source` and replaces calls
 * with `baseCallback`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeGetCallback(source, funcDepMap) {
  source = removeFunction(source, 'getCallback');

  _.each([
    'baseSortByOrder', 'createAggregator', 'createExtremum', 'createFind',
    'createFindIndex', 'createFindKey', 'createObjectMapper', 'createReduce',
    'createSortedIndex', 'dropRightWhile', 'dropWhile', 'every', 'filter', 'map',
    'reject', 'remove', 'some', 'sortBy', 'sum', 'takeRightWhile', 'takeWhile',
    'transform', 'uniq'
  ], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'getCallback');
    if (!_.includes(deps, 'baseCallback')) {
      deps.push('baseCallback');
    }
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(reGetCallback, 'baseCallback');
    });
  });

  _.each(['createExtremum', 'createSortedIndex', 'sum', 'uniq'], function(funcName) {
    var isCreateSortedIndex = funcName == 'createSortedIndex',
        useNoIteratee = /^(?:createExtremum|sum)$/.test(funcName);

    source = source.replace(matchFunction(source, funcName), function(match) {
      match = removeVar(match, 'func');
      if (isCreateSortedIndex) {
        return match
          .replace(/\(func[^)]+\)/, 'iteratee == null')
          .replace(/\bfunc(?=\()/, 'baseCallback');
      }
      return match.replace(/^( *)if\s*\(!\(func[\s\S]+?\n\1\}/m, function(match, indent) {
        return indent +
          'iteratee = ' + (useNoIteratee ? 'noIteratee' : 'iteratee == null') +
          ' ? iteratee : baseCallback(iteratee, thisArg, 3);';
      });
    });
  });

  source = source.replace(matchFunction(source, 'baseSortByOrder'), function(match) {
    match = removeVar(match, 'callback');
    return match.replace(/\bcallback(?=\()/, 'baseCallback');
  });

  return source.replace(getMethodAssignments(source), function(match) {
    _.each(['main', 'wrapperValue'], function(funcName) {
      var deps = _.result(funcDepMap, funcName, []);
      if (_.includes(deps, 'getCallback')) {
        _.pull(deps, 'getCallback').push('baseCallback');
        match = match.replace(reGetCallback, 'baseCallback');
        return false;
      }
    });
    return match;
  });
}

/**
 * Removes all references to `getIndexOf from `source` and replaces calls with
 * `baseIndexOf`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeGetIndexOf(source, funcDepMap) {
  source = removeFunction(source, 'getIndexOf');

  _.each(['baseDifference', 'baseUniq', 'includes', 'intersection', 'pull', 'uniq'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    if (_.includes(deps, 'getIndexOf')) {
      _.pull(deps, 'getIndexOf');
      if (funcName != 'uniq') {
        deps.push('baseIndexOf');
      }
      source = source.replace(matchFunction(source, funcName), function(match) {
        match = replaceVar(match, 'indexOf', 'baseIndexOf');
        return match
          // Replace all `getIndexOf` calls with `baseIndexOf`.
          .replace(/\bgetIndexOf\b(?:\(\))?/g, 'baseIndexOf')
          // Remove "indexOf" comparisons.
          .replace(/\bindexOf\s*==\s*baseIndexOf\b/, 'true')
          .replace(/\s*&&\s*baseIndexOf\s*==\s*baseIndexOf\b/, '');
      });
    }
  });
  return source;
}

/**
 * Removes the copyright/license header from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeHeader(source) {
  source = source == null ? '' : String(source);
  return source.replace(getHeader(source), '');
}

/**
 * Removes the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArgumentsFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsArgumentsFork(source), '');
}

/**
 * Removes the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArrayFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsArrayFork(source), '');
}

/**
 * Removes the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsElementFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsElementFork(source), '');
}

/**
 * Removes the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsFunctionFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getIsFunctionFork(source), '');
}

/**
 * Removes all `isHostObject` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeIsHostObject(source, funcDepMap) {
  source = source == null ? '' : String(source);

  _.each(['baseClone', 'baseIsEqualDeep', 'isElement', 'isNative', 'shimIsPlainObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isHostObject');
  });

  _.each(['baseIsEqualDeep', 'shimIsPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*&&\s*!isHostObject\([^)]+\)/g, '');
    });
  });

  source = source.replace(matchFunction(source, 'baseClone'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(isHostObject\b[\s\S]+?\n\1\}\n/m, '');
  });

  source = source.replace(matchFunction(source, 'isElement'), function(match) {
    return match.replace(/\(lodash\.support\.nodeTag\s*\?\s*([\s\S]+?)\s*:[\s\S]+?\)\)/, '$1');
  });

  return source.replace(matchFunction(source, 'isNative'), function(match) {
    return match.replace(/\s*\(isHostObject\b[^:]+:([\s\S]+?)\)/, '$1');
  });
}

/**
 * Removes the `@license` tag from the copyright header so minifiers and
 * build optimizers may strip them.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeLicenseTag(source) {
  source = source == null ? '' : String(source);
  return source.replace(/^ \* *@license\n/m, '');
}

/**
 * Removes a method assignment by name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} [methodName] The name of the method assignment to remove.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignment(source, methodName) {
  source = source == null ? '' : String(source);

  return source.replace(getMethodAssignments(source), function(match) {
    var reAssignment = RegExp(
      '^( *//.*\\n)* *' +
      '(?:lodash(?:\\.prototype)?\\.[$\\w]+\\s*=\\s*)*' +
      'lodash(?:\\.prototype)?\\.' +
      '(?:[$\\w]+\\s*=\\s*' + methodName + '|' + methodName + '\\s*=\\s*[$\\w]+);' +
      '\\n(\\n)?'
    , 'gm');

    return match.replace(reAssignment, function(match, comment, newline) {
      return (!newline && comment) || newline || '';
    });
  });
}

/**
 * Removes all lodash method assignments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignments(source) {
  source = source == null ? '' : String(source);
  return source.replace(getMethodAssignments(source), '');
}

/**
 * Removes all `_.mixin` calls from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeMixinCalls(source) {
  source = source == null ? '' : String(source);
  return source.replace(/^(?: *\/\/.*\n)*( *)mixin\(.+?(?:\{[\s\S]+?\n\1\}.+?)?\);\n/gm, '');
}

/**
 * Removes the `_.now` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeNowFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getNowFork(source), '');
}

/**
 * Removes the `_.parseInt` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeParseIntFork(source) {
  source = source == null ? '' : String(source);
  return source.replace(getParseIntFork(source), '');
}

/**
 * Removes a lodash property, of the given property name, from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} propName The name of the property to remove.
 * @returns {string} Returns the modified source.
 */
function removeProp(source, propName) {
  source = source == null ? '' : String(source);
  return source.replace(matchProp(source, propName, true), '');
}

/**
 * Removes all `runInContext` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeRunInContext(source) {
  source = removeVar(source, 'clearTimeout');
  source = removeVar(source, 'contextProps');
  source = removeVar(source, 'setTimeout');
  source = removeMethodAssignment(source, 'runInContext');

  // Remove function scaffolding, leaving most of its content.
  source = source.replace(matchFunction(source, 'runInContext', true), function(match) {
    match = replaceIndent(match, 2, 1);
    return match
      // Remove function frame.
      .replace(/^[\s\S]+?function\s+runInContext\b[\s\S]+?context\s*=\s*context.+?\n+| *return\s+lodash;[\s\S]+$/g, '')
      // Remove native constructor references.
      .replace(/^(?: *\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/\n)? *var\s+Array\s*=[\s\S]+?;\n/m, '')
      // Replace `context` references with `root`.
      .replace(/\bcontext\b/g, 'root');
  });

  return source
    // Remove `_` assignment.
    .replace(/^(?: *\/\/.*\n)* *var\s+_\s*=\s*runInContext\b.+\n+/m, '')
    // Replace `_` references with `lodash`.
    .replace(/(\breturn\s+|=\s*)_([;)])/g, '$1lodash$2');
}

/**
 * Removes the `support.spliceObjects` fix from the `Array` function mixins
 * snippet of `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeSpliceObjectsFix(source) {
  source = source == null ? '' : String(source);

  return source.replace(/^( *)arrayEach\(\['concat\b[\s\S]+?\n\1\}\);/m, function(match) {
    match = removeVar(match, 'fixObjects');
    match = removeVar(match, 'func');
    return match.replace(/\bprotoFunc\b/g, 'func');
  });
}

/**
 * Removes all strings from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeStrings(source) {
  source = source == null ? '' : String(source);
  return source.replace(reString, '');
}

/**
 * Removes all `support.argsTag` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportArgsTag(source, funcDepMap, objDepMap) {
  source = removeIsArgumentsFork(source);
  source = removeSupportProp(source, 'argsTag');

  _.each(['isArguments', 'isPlainObject', 'shimIsPlainObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isArguments');

    if (funcName != 'shimIsPlainObject') {
      deps = _.result(objDepMap, funcName, []);
      _.pull(deps, 'support');
    }
  });

  _.each(['shimIsPlainObject', 'isPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*\|\|\s*\(!(?:lodash\.)?support\.argsTag\b[\s\S]+?\)\)/, '');
    });
  });

  return source;
}

/**
 * Removes all `support.dom` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportDom(source, objDepMap) {
  var deps = _.result(objDepMap, 'isElement', []);
  _.pull(deps, 'support');

  source = removeSupportProp(source, 'dom');
  return removeIsElementFork(source);
}

/**
 * Removes all `support.enumErrorProps` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumErrorProps(source) {
  return removeSupportProp(source, 'enumErrorProps');
}

/**
 * Removes all `support.enumPrototypes` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumPrototypes(source, objDepMap) {
  var deps = _.result(objDepMap, 'keys', []);
  _.pull(deps, 'support');

  source = removeSupportProp(source, 'enumPrototypes');
  return source.replace(matchFunction(source, 'keys'), function(match) {
    return match.replace(/typeof\s+object[^:]+:/, "typeof object != 'function' &&");
  });
}

/**
 * Removes all `support.nodeTag` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportNodeTag(source, funcDepMap) {
  var deps = _.result(funcDepMap, 'isElement', []);
  _.pull(deps, 'isHostObject');

  source = removeSupportProp(source, 'nodeTag');
  return source.replace(matchFunction(source, 'isElement'), function(match) {
    return match.replace(/\(lodash\.support\.nodeTag\s*\?\s*([\s\S]+?)\s*:[\s\S]+?\)\)/, '$1');
  });
}

/**
 * Removes all `support.nonEnumArgs` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumArgs(source) {
  return removeSupportProp(source, 'nonEnumArgs');
}

/**
 * Removes all `support.nonEnumShadows` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumShadows(source) {
  return removeSupportProp(source, 'nonEnumShadows');
}

/**
 * Removes all `support.nonEnumStrings` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumStrings(source, funcDepMap, objDepMap) {
  var deps = _.result(funcDepMap, 'shimKeys', []);
  _.pull(deps, 'isString');

  deps = _.result(funcDepMap, 'has', []);
  _.pull(deps, 'isIndex', 'isString');

  deps = _.result(objDepMap, 'has', []);
  _.pull(deps, 'support');

  source = removeSupportProp(source, 'nonEnumStrings');

  source = source.replace(matchFunction(source, 'has'), function(match) {
    return match.replace(/\s*\|\|\s*\(lodash\.support\.nonEnumStrings\b[\s\S]+?\)(?=;\n)/, '');
  });

  return source.replace(matchFunction(source, 'shimKeys'), function(match) {
    return match.replace(/\s*\|\|\s*\(support\.nonEnumStrings\b[\s\S]+?\)\)(\s*\|\|\s*)?/, function(match, postlude) {
      return postlude ? postlude.replace(/\s+$/, ' ') : '';
    });
  });
}

/**
 * Removes all `support.ownLast` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportOwnLast(source) {
  source = removeSupportProp(source, 'ownLast');
  return source.replace(matchFunction(source, 'shimIsPlainObject'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(support\.ownLast\b[\s\S]+?\n\1\}\n/m, '');
  });
}

/**
 * Removes all `support.spliceObjects` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportSpliceObjects(source) {
  return removeSpliceObjectsFix(removeSupportProp(source, 'spliceObjects'));
}

/**
 * Removes all `support.unindexedChars` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Object} [funcDepMap] The function dependency map to modify.
 * @param {Object} [objDepMap] The object dependency map to modify.
 * @returns {string} Returns the modified source.
 */
function removeSupportUnindexedChars(source, funcDepMap, objDepMap) {
  _.each(['toIterable', 'toArray', 'toObject'], function(funcName) {
    var deps = _.result(funcDepMap, funcName, []);
    _.pull(deps, 'isString');

    deps =  _.result(objDepMap, funcName, []);
    _.pull(deps, 'support');
  });

  source = removeSupportProp(source, 'unindexedChars');

  _.each(['toIterable', 'toObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(lodash\.support\.unindexedChars\b[\s\S]+?\n\1\}\n/m, '');
    });
  });

  return source.replace(matchFunction(source, 'toArray'), function(match) {
    return match.replace(/\(lodash\.support\.unindexedChars\b[\s\S]+?:\s*/, '');
  });
}

/**
 * Removes a given property from the `support` object in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to remove.
 * @returns {string} Returns the modified source.
 */
function removeSupportProp(source, propName) {
  source = source == null ? '' : String(source);
  propName = _.escapeRegExp(propName);

  return source.replace(matchProp(source, 'support'), function(match) {
    return match.replace(RegExp(
      '\\n+' + commentPattern +
      // Match a `try` block.
      '(?:( *)try\\b.+\\n)?' +
      // Match the `support` property assignment.
      ' *support\\.' + propName + '\\s*=[\\s\\S]+?;(?=\\n)' +
      // Match the `catch` block.
      '(?:\\n\\1\\}\\s*catch\\b[\\s\\S]+?\\n\\1\\})?'
    , 'm'), '');
  });
}

/**
 * Removes a variable of the given variable name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable to remove.
 * @returns {string} Returns the modified source.
 */
function removeVar(source, varName) {
  source = source == null ? '' : String(source);

  _.some([
    function(source) {
      return removeFunction(source, varName);
    },
    function(source) {
      return source.replace(matchVar(source, varName, true), '');
    }
  ], function(func) {
    var result = func(source);
    if (result !== source) {
      source = result;
      return true;
    }
  });
  return source;
}

/**
 * Replaces the `funcName` function body in `source` with `funcValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to replace.
 * @param {string} funcValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceFunction(source, funcName, funcValue) {
  source = source == null ? '' : String(source);

  var checkFuncTag = reIsVarSnippet.test(funcValue),
      snippet = matchFunction(source, funcName, checkFuncTag);

  if (!snippet) {
    return source;
  }
  return source.replace(snippet, function(match) {
    var header = checkFuncTag ? getHeader(match) : '';
    if (header && !isFunctionSnippet(snippet)) {
      header = header.replace(/^( *)\* *(?:@(?:category|param|returns)\b|\/)/m, function(match, indent) {
        return indent + '* @type Function\n' + match;
      });
    }
    return header + funcValue
      .replace(RegExp('^' + getIndent(funcValue), 'gm'), getIndent(snippet))
      .trimRight() + '\n';
  });
}

/**
 * Replaces the IIFE that wraps `source` with `iife`. If the `%output%` token
 * is present in `iife` it will be replaced with the unwrapped `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} iife The replacement IIFE.
 * @returns {string} Returns the modified source.
 */
function replaceIIFE(source, iife) {
  source = source == null ? '' : String(source);
  iife = iife == null ? '' : String(iife);

  var token = '%output%',
      header = getHeader(source),
      index = iife.indexOf(token);

  if (index < 0) {
    return header + iife;
  }
  return header +
    iife.slice(0, index) +
    source.replace(/^[\s\S]+?\(function[^{]+\{\n+|\s*\}\.call\(this\)\)[;\s]*$/g, '\n') +
    iife.slice(index + token.length);
}

/**
 * Replaces the indent at level `from` of the given source with the level `to`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} from The indent level to be replaced.
 * @param {number} to The indent level to replace with.
 * @returns {string} Returns the modified source.
 */
function replaceIndent(source, from, to) {
  source = source == null ? '' : String(source);
  return source.replace(RegExp('^(?:  ){' + (from || 1) + '}', 'gm'), _.repeat('  ', to));
}

/**
 * Replaces the `support` object `propName` property value in `source` with `propValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to replace.
 * @returns {string} Returns the modified source.
 */
function replaceSupportProp(source, propName, propValue) {
  source = source == null ? '' : String(source);
  propName = _.escapeRegExp(propName);

  return source.replace(RegExp(
    // Match a `try` block.
    '^(?: *try\\b.+\\n)?' +
    // Match the `support` property assignment.
    '( *support\\.' + propName + '\\s*=).+\\n' +
    // Match the `catch` block.
    '(?:( *).+?catch\\b[\\s\\S]+?\\n\\2\\}\\n)?'
  , 'm'), function(match, left) {
    return left + ' ' + propValue + ';\n';
  });
}

/**
 * Replaces the `varName` variable declaration value in `source` with `varValue`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to replace.
 * @param {string} varValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceVar(source, varName, varValue) {
  source = source == null ? '' : String(source);
  varName = _.escapeRegExp(varName);

  // Replace a variable that's not part of a declaration list.
  var result = source.replace(RegExp(
    '(( *)var\\s+' + varName + '\\s*=)' +
    '(?:.+?;|(?:Function\\(.+?|.*?[^,])\\n[\\s\\S]+?\\n\\2.+?;)\\n'
  ), function(match, left) {
    return left + ' ' + varValue + ';\n';
  });

  if (source == result) {
    // Replace a varaible at the start or middle of a declaration list.
    result = source.replace(RegExp('((?:var|\\n)\\s+' + varName + '\\s*=).+?(?=,\\n)'), function(match, left) {
      return left + ' ' + varValue;
    });
  }
  if (source == result) {
    // Replace a variable at the end of a variable declaration list.
    result = source.replace(RegExp('(,\\s*' + varName + '\\s*=).+?(?=;\\n)'), function(match, left) {
      return left + ' ' + varValue;
    });
  }
  return result;
}

/**
 * Add or remove the "use strict" directive from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {boolean} value The value to set.
 * @returns {string} Returns the modified source.
 */
function setUseStrictOption(source, value) {
  source = source == null ? '' : String(source);
  return source.replace(/^([\s\S]*?function[^{]+\{)(?:\s*'use strict';)?/, '$1' + (value ? "\n  'use strict';" : ''));
}

/**
 * Invokes `callback` providing `source` with strings removed and returns the
 * modified source with strings restored.
 *
 * @private
 * @param {string} source The source to modify.
 * @param {Function} [callback] The function to modify the string free source.
 * @returns {string} Returns the modified source.
 */
function stringFree(source, callback) {
  var strings = [];
  source = source == null ? '' : String(source);
  source = callback(source.replace(reString, function(match) {
    var index = strings.length;
    strings.push(match);
    return '<#str_token' + index + '#>';
  })) || '';

  source = source == null ? '' : String(source);
  return source.replace(reStringToken, function(match) {
    return strings[match.slice(11, -2)];
  });
}

/**
 * Trims the indent of the specified level from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} level The level of indent to trim.
 * @returns {string} Returns the modified source.
 */
function trimIndent(source, level) {
  return replaceIndent(source, level || 1);
}

/*----------------------------------------------------------------------------*/

/**
 * Creates a debug and/or minified build, invoking the callback for each. The
 * `callback` is invoked with one argument; (data).
 *
 * Note: For a list of commands see `HELP_TEXT` or run `lodash --help`.
 *
 * @param {Array|Object} [options=[]] An array of build commands or the state object.
 * @param {Function} [callback=defaultBuildCallback] The function called per build.
 */
function build(options, callback) {
  options || (options = []);
  callback || (callback = defaultBuildCallback);

  // Used to specify the output path for builds.
  var outputPath;

  // Used to specify the source map URL.
  var sourceMapURL;

  // Used to track the time it takes to complete a build.
  var stamp = _.now();

  // Used to pre-populate the build state.
  var state = _.isPlainObject(options) && options;

  var isExcluded = function() {
    return _.every(arguments, function(value) {
      return !_.includes(buildFuncs, value);
    });
  };

  if (state) {
    var buildFuncs = state.buildFuncs,
        filePath = state.filePath,
        funcDepMap = state.funcDepMap,
        funcTokenMap = state.funcTokenMap,
        includeFuncs = state.includeFuncs,
        includeObjs = state.includeObjs,
        includeVars = state.includeVars,
        isDevelopment = true,
        isModularize = true,
        isStdOut = state.isStdOut,
        isStrict = state.isStrict,
        minusFuncs = [],
        objDepMap = state.objDepMap,
        outputPath = state.outputPath,
        plusFuncs = [],
        source = state.source,
        varDepMap = state.varDepMap,
        varNames = state.varNames;
  }
  else {
    // Clone dependencies to modify.
    var funcDepMap = createMap(_.cloneDeep(mapping.funcDep)),
        objDepMap = createMap(_.cloneDeep(mapping.objDep)),
        varDepMap = createMap(_.cloneDeep(mapping.varDep));

    // The path to the source file.
    var filePath = require.resolve('lodash-compat');

    // Used to specify a custom IIFE to wrap lodash.
    var iife = getOption(options, 'iife');

    // Used to match external template files to precompile.
    var templatePattern = getOption(options, 'template', '');

    // Used as the template settings for precompiled templates.
    var templateSettings = (function() {
      var result = getOption(options, 'settings');
      return result
        ? Function('return {' + result.replace(/^\{|\}$/g, '') + '}')()
        : _.clone(_.templateSettings);
    }());

    // A flag to specify only creating the development build.
    var isDevelopment = getOption(options, '-d') || getOption(options, '--development');

    // A flag to indicate that a custom IIFE was specified.
    var isIIFE = typeof iife == 'string';

    // A flag to specify creating a source map for the minified source.
    var isMapped = getOption(options, '-m') || getOption(options, '--source-map');

    // A flag to specify a modern build.
    var isModern = getOption(options, 'modern');

    // A flag to specify a modularize build.
    var isModularize = getOption(options, 'modularize');

    // A flag to specify only creating the minified build.
    var isProduction = getOption(options, '-p') || getOption(options, '--production');

    // A flag to specify writing output to standard output.
    var isStdOut = getOption(options, '-c') || getOption(options, '--stdout');

    // A flag to specify skipping status updates normally logged to the console.
    var isSilent = !isBin || isStdOut || getOption(options, '-s') || getOption(options, '--silent');

    // A flag to specify `_.assign`, `_.bindAll`, and `_.defaults`
    // are constructed using the "use strict" directive.
    var isStrict = getOption(options, 'strict');

    // A flag to specify a template build.
    var isTemplate = !!templatePattern;

    // Used to specify the AMD module ID of lodash used by precompiled templates.
    var moduleId = getOption(options, 'moduleId', null);

    // Used as the output path for the build.
    var outputPath = _.reduce(options, function(result, value, index) {
      return /^(?:-o|--output)$/.test(value)
        ? path.normalize(options[index + 1])
        : result;
    }, isModularize ? '.' + path.sep + 'modularize' : '');

    // Used to specify the ways to export the `lodash` function.
    var exportsOptions = (function() {
      var result = getOption(options, 'exports', isModularize ? ['amd'] : listing.exports);
      if (!isModularize && _.includes(result, 'umd')) {
        result = _.union(result, listing.exports);
      }
      return isModularize ? _.take(result, 1) : result;
    }());

    // A flag to specify creating a custom build.
    var isCustom = !isModularize && (
      isMapped || isModern || isStrict || isTemplate || outputPath ||
      getOption(options, 'compat') ||
      /\b(?:category|exports|iife|include|minus|moduleId|plus)=/.test(options) ||
      !_.isEqual(exportsOptions, listing.exports)
    );

    // Flags to specify export options.
    var isAMD = _.includes(exportsOptions, 'amd'),
        isCommonJS = _.includes(exportsOptions, 'commonjs'),
        isES = _.includes(exportsOptions, 'es') || _.includes(exportsOptions, 'es6'),
        isGlobal = _.includes(exportsOptions, 'global'),
        isNpm = _.includes(exportsOptions, 'npm'),
        isNode = isNpm || _.includes(exportsOptions, 'iojs') || _.includes(exportsOptions, 'node');

    if (isES) {
      _.pull(exportsOptions, 'es', 'es6').push('es');
    }
    if (isNode) {
      _.pull(exportsOptions, 'iojs', 'node').push('node');
    }
    if (isTemplate) {
      isModern = isModularize = false;
    }
    // The lodash.js source.
    var source = fs.readFileSync(filePath, 'utf8');

    /*------------------------------------------------------------------------*/

    // Categories of functions to include in the build.
    var categoryOptions = _.map(getOption(options, 'category', []), function(category) {
      return getRealCategory(_.capitalize(category.toLowerCase()));
    });

    // Functions to include in the build.
    var includeFuncs = _.union(categoryOptions, _.map(getOption(options, 'include', []), getRealName));

    // Properties to include in the build.
    var includeObjs = _.intersection(includeFuncs, listing.objDeps);

    // Variables to include in the build.
    var includeVars = _.intersection(includeFuncs, listing.varDeps);

    // Functions to remove from the build.
    var minusFuncs = _.map(getOption(options, 'minus', []), getRealName);

    // Functions to add to the build.
    var plusFuncs = _.map(getOption(options, 'plus', []), getRealName);

    // Expand categories to function names.
    _.each([includeFuncs, minusFuncs, plusFuncs], function(funcNames) {
      var categories = _.intersection(funcNames, listing.categories);

      _.each(categories, function(category) {
        push.apply(funcNames, _.filter(getNamesByCategory(category), function(key) {
          var type = typeof _[key];
          return type == 'function' || type == 'undefined';
        }));
      });
    });

    // Remove categories from function names.
    includeFuncs = _.difference(includeFuncs, listing.categories, includeObjs, includeVars);
    minusFuncs = _.difference(minusFuncs, listing.categories);
    plusFuncs = _.difference(plusFuncs, listing.categories);

    /*------------------------------------------------------------------------*/

    // Used to capture warnings for invalid command-line arguments.
    var warnings = [];

    // Used to detect invalid command-line arguments.
    var invalidArgs = _.reject(options, function(value, index, options) {
      if (/^(?:-o|--output)$/.test(options[index - 1]) ||
          /^(?:category|exports|iife|include|moduleId|minus|plus|settings|template)=[\s\S]*$/.test(value)) {
        return true;
      }
      var result = _.includes([
        'compat',
        'modern',
        'modularize',
        'strict',
        '-c', '--stdout',
        '-d', '--development',
        '-h', '--help',
        '-m', '--source-map',
        '-o', '--output',
        '-p', '--production',
        '-s', '--silent',
        '-V', '--version'
      ], value);

      if (!result && /^(?:-m|--source-map)$/.test(options[index - 1])) {
        sourceMapURL = value;
        return true;
      }
      return result;
    });

    // Report invalid command and option arguments.
    if (!_.isEmpty(invalidArgs)) {
      warnings.push('Invalid argument' + (_.size(invalidArgs) > 1 ? 's' : '') + ' passed: ' + invalidArgs.join(', '));
    }
    // Report invalid command combinations.
    invalidArgs = _.intersection(options, ['compat', 'modern']);

    if (isTemplate) {
      invalidArgs.push('template');
    }
    if (_.size(invalidArgs) > 1) {
      warnings.push('The `' + invalidArgs.slice(0, -1).join('`, `') + '`' + (_.size(invalidArgs) > 2 ? ',' : '') + ' and `' + invalidArgs.slice(-1) + '` commands may not be combined.');
    }
    // Report invalid command entries.
    _.forOwn({
      'category': {
        'entries': categoryOptions,
        'validEntries': listing.categories
      },
      'exports': {
        'entries': exportsOptions,
        'validEntries': isModularize
          ? _.without(listing.exports.concat(['es', 'npm']), 'global')
          : listing.exports
      },
      'include': {
        'entries': includeFuncs,
        'validEntries': listing.funcs
      },
      'minus': {
        'entries': minusFuncs,
        'validEntries': listing.funcs
      },
      'plus': {
        'entries': plusFuncs,
        'validEntries': listing.funcs
      }
    }, function(data, commandName) {
      invalidArgs = _.difference(data.entries, data.validEntries, ['none']);
      if (!_.isEmpty(invalidArgs)) {
        warnings.push('Invalid `' + commandName + '` entr' + (_.size(invalidArgs) > 1 ? 'ies' : 'y') + ' passed: ' + invalidArgs.join(', '));
      }
    });

    if (!_.isEmpty(warnings)) {
      var warnText = [
        '',
        warnings,
        'For more information type: lodash --help'
      ].join('\n');

      if (isBin) {
        console.warn(warnText);
        process.exit(1);
      } else {
        callback(_.create(Error.prototype, { 'message': warnText, 'source': warnText }));
      }
      return;
    }
    // Display the help message.
    if (getOption(options, '-h') || getOption(options, '--help')) {
      if (isBin) {
        console.log(HELP_TEXT);
      } else {
        callback({ 'source': HELP_TEXT });
      }
      return;
    }
    // Display the `lodash.VERSION`.
    if (getOption(options, '-V') || getOption(options, '--version')) {
      if (isBin) {
        console.log(_.VERSION);
      } else {
        callback({ 'source': _.VERSION });
      }
      return;
    }

    /*------------------------------------------------------------------------*/

    // The names of functions to include in the build.
    var buildFuncs = !isTemplate && (function() {
      source = setUseStrictOption(source, isStrict);

      if (isModularize) {
        if (isNode) {
          // Remove `root` from `varDepMap` identifiers.
          _.forOwn(varDepMap, function(depNames) {
            _.pull(depNames, 'root');
          });

          // Replace `root` references with `global`.
          _.each(['createBindWrapper', 'createHybridWrapper', 'createPartialWrapper'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/\broot\b/g, 'global');
            });
          });

          delete varDepMap.root;
        }
        // Add deps to wrap `_.mixin` in `main`.
        funcDepMap.main.push('baseFunctions', 'isObject', 'keys');

        // Remove `lodash` from function deps.
        _.each(listing.placeholderFuncs.concat('createCurry', 'createPartial', 'mixin'), function(funcName) {
          _.pull(funcDepMap[funcName], 'lodash');
        });
      }
      else {
        // Redistribute `main` deps for chaining.
        funcDepMap.chain.push('wrapperChain');
        funcDepMap.wrapperValue = _.union(funcDepMap.wrapperValue, _.without(funcDepMap.main, 'lodash', 'LodashWrapper'));

        // Add `arrayEach` to functions with placeholder support because it's
        // used to reduce code for placeholder assignments
        _.each(listing.placeholderFuncs, function(funcName) {
          funcDepMap[funcName].push('arrayEach');
        });

        // Associate "Chain" methods with `wrapperValue`.
        _.each(_.without(mapping.category.Chain, 'lodash', 'wrapperValue'), function(funcName) {
          funcDepMap.wrapperValue.push(funcName);
          funcDepMap[funcName].push('wrapperValue');
        });
      }
      if (isModern) {
        _.pull(objDepMap.shimIsPlainObject, 'support');

        source = removeIsHostObject(source, funcDepMap);
        source = removeSupportArgsTag(source, funcDepMap, objDepMap);
        source = removeSupportEnumErrorProps(source);
        source = removeSupportEnumPrototypes(source, objDepMap);
        source = removeSupportNodeTag(source, funcDepMap);
        source = removeSupportNonEnumShadows(source);
        source = removeSupportNonEnumStrings(source, funcDepMap, objDepMap);
        source = removeSupportOwnLast(source);
        source = removeSupportSpliceObjects(source);
        source = removeSupportUnindexedChars(source, funcDepMap, objDepMap);

        // Simplify `initCloneByTag`.
        _.pull(varDepMap.initCloneByTag, 'root');

        source = source.replace(matchFunction(source, 'initCloneByTag'), function(match) {
          return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(Ctor\s+instanceof\s+Ctor[\s\S]+?\n\1\}\n/m, '');
        });

        // Optimize functions by moving `toObject`.
        _.each(['baseGet', 'baseMatches'], function(funcName) {
          source = source.replace(matchFunction(source, funcName), function(match) {
            if (funcName == 'baseGet') {
              match = match.replace(reToObject, '$1');
            }
            return match
              .replace(/^ *object\s*=[^;]+;\n/m, '')
              .replace(/\b(key|pathKey)\s+in\s+object\b/, '$1 in toObject(object)');
          });
        });

        // Optimize functions by removing `toObject`.
        _.each(['baseProperty', 'result'], function(funcName) {
          _.pull(funcDepMap[funcName], 'toObject');
          source = source.replace(matchFunction(source, funcName), function(match) {
            return match.replace(reToObject, '$1');
          });
        });

        // Replace `_.at`.
        _.pull(funcDepMap.at, 'isArrayLike', 'toIterable');

        source = replaceFunction(source, 'at', [
          'var at = restParam(function(collection, props) {',
          '  return baseAt(collection, baseFlatten(props));',
          '});'
        ].join('\n'));

        // Replace `_.isRegExp`.
        _.pull(funcDepMap.isRegExp, 'isObject').push('isObjectLike');

        source = replaceFunction(source, 'isRegExp', [
          'function isRegExp(value) {',
          '  return isObjectLike(value) && objToString.call(value) == regexpTag;',
          '}'
        ].join('\n'));

        // Replace `_.keysIn`.
        _.pull(funcDepMap.keysIn, 'arrayEach', 'isFunction', 'isString');

        source = replaceFunction(source, 'keysIn', [
          'function keysIn(object) {',
          '  if (object == null) {',
          '    return [];',
          '  }',
          '  if (!isObject(object)) {',
          '    object = Object(object);',
          '  }',
          '  var length = object.length;',
          '  length = (length && isLength(length) &&',
          '    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;',
          '',
          '  var Ctor = object.constructor,',
          '      index = -1,',
          "      isProto = typeof Ctor == 'function' && Ctor.prototype === object,",
          '      result = Array(length),',
          '      skipIndexes = length > 0;',
          '',
          '  while (++index < length) {',
          "    result[index] = (index + '');",
          '  }',
          '  for (var key in object) {',
          '    if (!(skipIndexes && isIndex(key, length)) &&',
          "        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {",
          '      result.push(key);',
          '    }',
          '  }',
          '  return result;',
          '}'
        ].join('\n'));
      }
      if (isModularize) {
        source = removeGetIndexOf(source, funcDepMap);
        source = removeGetCallback(source, funcDepMap);
      }
      if (isNpm) {
        source = removeMetadata(source, funcDepMap, objDepMap, varDepMap);

        // Remove `nativeAssign` from `baseAssign`
        _.pull(funcDepMap.baseAssign, 'isNative');

        source = source.replace(matchFunction(source, 'baseAssign'), function(match) {
          return match.replace(/\bnativeAssign\s*\|\|\s*/, '');
        });

        // Replace `createFlow`.
        _.pull(funcDepMap.createFlow, 'getData', 'getFuncName', 'isArray', 'isLaziable', 'LodashWrapper');

        source = replaceFunction(source, 'createFlow', [
          'function createFlow(fromRight) {',
          '  return function() {',
          '    var length = arguments.length;',
          '    if (!length) {',
          '      return function() { return arguments[0]; };',
          '    }',
          '    var index = fromRight ? length : -1,',
          '        leftIndex = 0,',
          '        funcs = Array(length);',
          '',
          '    while ((fromRight ? index-- : ++index < length)) {',
          '      var func = funcs[leftIndex++] = arguments[index];',
          "      if (typeof func != 'function') {",
          '        throw new TypeError(FUNC_ERROR_TEXT);',
          '      }',
          '    }',
          '    return function() {',
          '      var index = 0,',
          '          result = funcs[index].apply(this, arguments);',
          '',
          '      while (++index < length) {',
          '        result = funcs[index].call(this, result);',
          '      }',
          '      return result;',
          '    };',
          '  };',
          '}'
        ].join('\n'));
      }
      // Remove "_.matches" or "_.property" style callback support from `baseCallback`.
      if (_.includes(minusFuncs, 'matches')) {
        _.pull(funcDepMap.callback, 'isObjectLike', 'matches');
        source = source.replace(matchFunction(source, 'callback'), function(match) {
          return match.replace(/^( *return\s+)[^:]+:\s*/m, '$1');
        });
      }
      _.each(['baseMatches', 'baseMatchesProperty', 'property'], function(funcName) {
        var otherName = _.camelCase(_.trimLeft(funcName, 'base'));
        if (_.includes(minusFuncs, otherName)) {
          _.pull(funcDepMap.baseCallback, funcName);
          source = source.replace(matchFunction(source, 'baseCallback'), function(match) {
            return match.replace(RegExp('\\b' + funcName + '\\([\\s\\S]+?\\)(?=[;\\n])', 'm'), 'identity');
          });
        }
      });

      // Add function names explicitly.
      if (!_.isEmpty(includeFuncs)) {
        var result = includeFuncs;
      }
      // Add default function names.
      else if (_.isEmpty(includeObjs) && _.isEmpty(includeVars)) {
        result = _.clone(listing.includes);
      }
      // Remove special "none" entry.
      if (_.isEqual(result, ['none'])) {
        result = [];
      } else {
        _.pull(result, 'none');
      }
      // Force removing or adding deps.
      if (isModularize) {
        minusFuncs.push('noConflict', 'runInContext');
      } else {
        plusFuncs.push('lodash');
      }
      // Add extra function names.
      if (!_.isEmpty(plusFuncs)) {
        result = _.union(result, plusFuncs);
      }
      // Subtract function names.
      if (!_.isEmpty(minusFuncs)) {
        result = _.difference(result, minusFuncs.concat(getDependants(minusFuncs, funcDepMap, true)));
      }
      result = _.uniq(result);

      var hasLodash = _.includes(result, 'lodash');
      result = getDependencies(_.without(result, 'lodash'), funcDepMap, true, ['lodash']);

      // Simplify `lodash` when not capable of chaining.
      if (!_.includes(result, 'main') && !_.includes(result, 'mixin') && !_.includes(result, 'wrapperValue')) {
        funcDepMap.lodash.length = 0;

        source = replaceFunction(source, 'lodash', [
          'function lodash() {',
          '  // No operation performed.',
          '}'
        ].join('\n'));
      }
      if (hasLodash) {
        result = _.union(result, ['lodash'], getDependencies('lodash', funcDepMap, true));
      }
      return result;
    }());

    // Expand properties, variables, and their function dependencies to include in the build.
    var allDeps = getAllDependencies(buildFuncs, funcDepMap, objDepMap, varDepMap).sort();
    buildFuncs = _.intersection(listing.funcs, allDeps);
    includeObjs = _.intersection(listing.objDeps, allDeps);
    includeVars = _.intersection(listing.varDeps, allDeps);

    /*------------------------------------------------------------------------*/

    // Load customized lodash module.
    var lodash = !isTemplate && (function() {
      var context = vm.createContext({
        'clearTimeout': clearTimeout,
        'console': console,
        'setTimeout': setTimeout
      });

      vm.runInContext(source, context);
      return context._;
    }());

    /*------------------------------------------------------------------------*/

    if (isTemplate) {
      source = buildTemplate({
        'moduleId': moduleId,
        'source': source,
        'templatePattern': templatePattern,
        'templateSettings': templateSettings
      });
    }
    else if (isModularize) {
      // Unexpose `lodash.support`.
      _.forOwn(mapping.objDep, function(deps, funcName) {
        if (_.includes(deps, 'support')) {
          source = source.replace(matchFunction(source, funcName), function(match) {
            return removeVar(match, 'support');
          });
        }
      });

      source = source
        .replace(/\blodash\.support\s*=\s*/, '')
        .replace(/\blodash\.(?=support\b)/g, '');

      // Replace the `lodash.templateSettings` property assignment with a variable assignment.
      source = source.replace(/\b(lodash\.)(?=templateSettings\s*=)/, 'var ');

      // Remove the `lodash` namespace from properties.
      source = source.replace(/( *)lodash\.([$\w]+\.)?([$\w]+)(\s*=\s*(?:function\([\s\S]+?\n\1\}|.+?);\n)?/g, function(match, indent, property, identifier, right) {
        return (property || right || identifier == 'com' || identifier == 'prototype')
          ? match
          : (indent + identifier);
      });

      // Remove all horizontal rule comment separators.
      source = source.replace(/^ *\/\*-+\*\/\n/gm, '');

      // Remove `lodash` branch in `_.mixin`.
      source = source.replace(matchFunction(source, 'mixin'), function(match) {
        match = match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(options\s*==\s*null\b[\s\S]+?\n\1\}\n/m, '');
        return match.replace(/^(?: *\/\/.*\n)*( *)if\s*\(!methodNames\b[\s\S]+?\n\1\}/m, function(match, indent) {
          return indent + 'var methodNames = baseFunctions(source, keys(source));\n';
        });
      });

      // Replace `sample` references in `lodash.prototype.sample` method with `collection.sample`.
      source = source.replace(getMethodAssignments(source), function(match) {
        return match.replace(/^( *)lodash\.prototype\.sample\s*=[\s\S]+?\n\1\}/m, function(match) {
          return match.replace(/\bsample(?=\()/g, 'collection.sample');
        });
      });

      // Replace `lodash` use in `_.templateSettings.imports`.
      source = source.replace(matchProp(source, 'templateSettings'), function(match) {
        return match.replace(/(:\s*)lodash\b/, "$1{ 'escape': escape }");
      });

      source = source.replace(matchFunction(source, 'template'), function(match) {
        // Assign `settings` using `template.imports`.
        match = match.replace(/=\s*templateSettings(?=[,;])/, '$&.imports._.templateSettings || templateSettings');

        // Remove default `sourceURL` value.
        return match.replace(matchVar(match, 'sourceURL'), function(match) {
          return match.replace(/=[\s\S]+?(?=;\n$)/, "= 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\\n' : ''");
        });
      });

      if (isNode) {
        source = source.replace(/\bcontext(?=\.)/g, 'global');
      }
      if (!isAMD) {
        source = removeVar(source, 'undefined');
      }
    }
    if (!isTemplate) {
      // Remove functions and method assignments from the build.
      _.each(_.difference(listing.funcs, buildFuncs), function(funcName) {
        source = removeFunction(source, funcName);
        if (!isModularize) {
          source = removeMethodAssignment(source, funcName);
        }
      });

      // Tokenize functions to reduce modularized build times.
      if (isModularize) {
        funcTokenMap = _.transform(buildFuncs, function(result, funcName) {
          var match = matchFunction(source, funcName, true);
          source = source.replace(match, '<<' + funcName + '>>\n');
          result[funcName] = match;
        }, createMap());
      }
      // Detect variables after tokenizing functions.
      varNames = _.difference(getVars(source), buildFuncs.concat(includeObjs, includeVars, 'freeGlobal'));
    }

    /*------------------------------------------------------------------------*/

    // Set the AMD module ID.
    if (isAMD && !isModularize && !isTemplate && moduleId != null && moduleId != 'none') {
      source = source.replace(/^ *define\((?=function)/m, "$&'" + moduleId + "', ");
    }
    // Customize lodash's export bootstrap.
    if (!isAMD || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if\s*\(typeof\s+define\b[\s\S]+?else\s+/m, '$1');
    }
    if (!isNode || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if\s*\(moduleExports\b[\s\S]+?else\s*\{([\s\S]+?\n)\1\}\n+/m, '$1$2');
    }
    if (!isCommonJS || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)\}?)\s*else\s*\{)?\s*freeExports\.[$\w]+\s*=[\s\S]+?(?:\n\2\})?\n+/m, function(match, prelude) {
        return _.trim(prelude) ? prelude + '\n' : '';
      });
    }
    if (!isGlobal || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)\}?)\s*else(?:\s*if\s*\(_\))?\s*\{)?(?:\s*\/\/.*)*\s*(?:root\._|_\.templates)\s*=[\s\S]+?(?:\n\2\})?\n+/gm, function(match, prelude) {
        return _.trim(prelude) ? prelude + '\n' : '';
      });
    }
    // Remove `if (freeExports && freeModule) {...}` if it's empty.
    if (isAMD && isGlobal) {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else\s+)?if\s*\(freeExports.*?\)\s*\{\s*\}\n+/m, '');
    } else {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else\s+)?if\s*\(freeExports.*?\)\s*\{\s*\}(?:\s*else\s*\{([\s\S]+?\n)\s*\})?\n+/m, '$1');
    }

    /*------------------------------------------------------------------------*/

    source = cleanupSource(source);

    // Exit early to create modules.
    if (isModularize) {
      if (callback == defaultBuildCallback) {
        callback = null;
      }
      buildModule({
        'buildFuncs': buildFuncs,
        'filePath': filePath,
        'funcDepMap': funcDepMap,
        'funcTokenMap': funcTokenMap,
        'includeFuncs': includeFuncs,
        'includeObjs': includeObjs,
        'includeVars': includeVars,
        'isAMD': isAMD,
        'isCommonJS': isCommonJS,
        'isES': isES,
        'isModern': isModern,
        'isNode': isNode,
        'isNpm': isNpm,
        'isSilent': isSilent,
        'isStdOut': isStdOut,
        'isStrict': isStrict,
        'lodash': lodash,
        'minusFuncs': minusFuncs,
        'objDepMap': objDepMap,
        'options': options,
        'outputPath': outputPath,
        'plusFuncs': plusFuncs,
        'source': source,
        'stamp': stamp,
        'varDepMap': varDepMap,
        'varNames': varNames
      }, callback);
      return;
    }
  }

  /*--------------------------------------------------------------------------*/

  // Modify/remove references to removed functions/variables.
  if (!isTemplate) {
    // Remove forks of removed functions.
    _.forOwn({
      'bufferClone': removeBufferCloneFork,
      'isArguments': removeIsArgumentsFork,
      'isArray': removeIsArrayFork,
      'isElement': removeIsElementFork,
      'isFunction': removeIsFunctionFork,
      'now': removeNowFork,
      'parseInt': removeParseIntFork
    },
    function(removeFork, funcName) {
      if (isExcluded(funcName)) {
        source = removeFork(source);
      }
    });

    // Remove prototype assignments.
    _.each(['MapCache', 'SetCache'], function(funcName) {
      if (isExcluded(funcName)) {
        source = source.replace(RegExp('^(?: *\\/\\/.*\\n)* *' + funcName + '\\.prototype(?:\\.[$\\w]+|\\[\'[^\']+\'\\])\\s*=[^;]+;\\n', 'gm'), '');
      }
    });

    if (isExcluded('memoize')) {
      // Remove `memoize.Cache` assignment.
      source = source.replace(/^(?: *\/\/.*\n)* *memoize\.Cache\s*=[^;]+;\n/m, '');
    }
    if (isExcluded('LazyWrapper')) {
      // Remove `LazyWrapper.prototype` assignment.
      source = source.replace(/^(?: *\/\/.*\n)* *LazyWrapper\.prototype(\.constructor)?\s*=[^;]+;\n/gm, '');
    }
    if (isExcluded('lodash') || !_.includes(funcDepMap.lodash, 'baseLodash')) {
      // Remove `lodash.prototype` assignment.
      source = source.replace(/^(?: *\/\/.*\n)* *lodash\.prototype(\.constructor)?\s*=[^;]+;\n/gm, '');
    }
    if (isExcluded('LodashWrapper')) {
      // Remove `LodashWrapper.prototype` assignment.
      source = source.replace(/^(?: *\/\/.*\n)* *LodashWrapper\.prototype(\.constructor)?\s*=[^;]+;\n/gm, '');
    }
    if (isExcluded(isModularize ? 'main' : 'mixin')) {
      source = removeMixinCalls(source);
    }
    if (isExcluded(isModularize ? 'main' : 'wrapperValue')) {
      source = removeChaining(source);
    }
    if (isModularize) {
      if (isExcluded('main')) {
        source = removeAssignments(source);
      }
    }
    else if (isExcluded('wrapperValue')) {
      source = removeChaining(source);
    }
    // Remove placeholder assignments of removed functions.
    source = source.replace(/^((?: *\/\/.*\n)*)( *)(arrayEach\(\[')bind\b[\s\S]+?('\][\s\S]+?\n\2\}\))/m, function(match, comment, indent, prelude, postlude) {
      var funcNames = _.reject(listing.placeholderFuncs, isExcluded),
          length = funcNames.length;

      if (length > 1) {
        return (comment + indent + prelude + funcNames.join("', '") + postlude);
      }
      return length
        ? (comment + indent + funcNames[0] + '.placeholder = ') + (isModularize ? '{}' : 'lodash')
        : '';
    });

    // Remove unneeded `support` properties.
    if (_.includes(includeObjs, 'support')) {
      if (!_.isEmpty(buildFuncs)) {
        if (isExcluded('isArguments', 'isPlainObject', 'shimIsPlainObject')) {
          source = removeSupportArgsTag(source);
        }
        if (isExcluded('isElement')) {
          source = removeSupportNodeTag(source);
        }
        if (isExcluded('isArguments')) {
          source = replaceSupportProp(source, 'argsTag', 'true');
        }
        if (isExcluded('isElement')) {
          source = removeSupportDom(source);
        }
        if (isExcluded('isPlainObject')) {
          source = removeSupportOwnLast(source);
        }
        if (isExcluded('keysIn')) {
          source = removeSupportNonEnumShadows(source);
        }
        if (isExcluded('keysIn', 'shimKeys')) {
          source = removeSupportNonEnumArgs(source);
          source = removeSupportNonEnumStrings(source);
        }
      }
      source = source.replace(matchProp(source, 'support'), function(match) {
        return match.replace(/^ *\(function\(x\)[^{]+\{\n(( *)var\s+Ctor\s*=[\s\S]+?\n *for\b[\s\S]+?\}\n)([\s\S]+?)\}\(0,\s*0\)\);\n/m, function(match, setup, indent, body) {
          var modified = setup;

          if (!/\.spliceObjects\s*=\s*(?!false\b|true\b)/.test(body)) {
            modified = removeVar(modified, 'object');
          }
          if (!/\.enumPrototypes\s*=\s*(?!false\b|true\b)/.test(body) &&
              !/\.nonEnumShadows\s*=\s*(?!false\b|true\b)/.test(body) &&
              !/\.ownLast\s*=\s*(?!false\b|true\b)/.test(body)) {
            modified = removeVar(modified, 'Ctor');
            modified = removeVar(modified, 'props');
            modified = modified
              .replace(/^ *Ctor\.prototype\b[\s\S]+?;\n/m, '')
              .replace(/^ *for\s*\(var\s+key\b[\s\S]+?\}\n/m, '');
          }
          // If there's no setup code then remove the IIFE.
          return (_.trim(modified) || /\barguments\b/.test(body))
            ? match.replace(setup, modified)
            : body.replace(RegExp('^' + indent, 'gm'), indent.slice(0, -2));
        });
      });
    }
    // Remove unneeded property dependencies.
    _.each(_.difference(listing.objDeps, includeObjs), function(propName) {
      source = removeProp(source, propName);
    });

    // Remove unneeded variable dependencies.
    _.each(_.difference(listing.varDeps, includeVars.concat('root')), function(varName) {
      source = removeVar(source, varName);
    });

    if (!(isAMD || isGlobal) && !_.includes(includeVars, 'root')) {
      varNames = _.without(varNames, 'root');
      source = removeVar(source, 'freeGlobal');
      source = removeVar(source, 'root');
    }
    if (isModularize) {
      // Untokenize functions to include in the build.
      _.each(buildFuncs, function(funcName) {
        source = source.replace('<<' + funcName + '>>\n', function() {
          return funcTokenMap[funcName];
        });
      });
      source = source.replace(reNamedToken, '');
    }
    // Remove unused variables.
    source = stringFree(source, function(source) {
      return commentFree(source, function(source) {
        var useMap = createMap();
        while (varNames.length) {
          varNames = _.sortBy(varNames, function(varName) {
            var result = isVarUsed(source, varName);
            useMap[varName] = result;
            return result;
          });

          while (varNames.length && useMap[varNames[0]]) {
            varNames.shift();
          }
          while (varNames.length && !useMap[varNames[0]]) {
            source = removeVar(source, varNames[0]);
            varNames.shift();
          }
        }
        return source;
      });
    });
  }
  // Customize lodash's IIFE.
  if (isIIFE) {
    source = replaceIIFE(source, iife);
  }

  /*--------------------------------------------------------------------------*/

  source = cleanupSource(source);

  // A flag to track if `outputPath` has been used by `callback`.
  var outputUsed = false;

  // Expand `outputPath` and create directories if needed.
  if (outputPath) {
    outputPath = (function() {
      var dirname = path.dirname(outputPath);
      fs.mkdirpSync(dirname);
      return path.join(fs.realpathSync(dirname), path.basename(outputPath));
    }());
  }
  // Resolve the basename of the output path.
  var basename = filePath = outputPath;
  if (!basename) {
    basename = 'lodash';
    if (isTemplate) {
      basename += '.templates';
    } else if (isCustom) {
      basename += '.custom';
    }
    filePath =  path.join(cwd, basename + '.js');
  }
  // Output development build.
  if (!isProduction && (isCustom || isDevelopment || isTemplate)) {
    var devSource = source;
    if (isCustom) {
      devSource = addCommandsToHeader(devSource, options);
    }
    if (isDevelopment && isStdOut) {
      stdout.write(devSource);
      callback({
        'source': devSource
      });
    }
    else if (!isStdOut) {
      outputUsed = true;
      callback({
        'source': devSource,
        'outputPath': filePath
      });
    }
  }
  // Begin the minification process.
  if (!isDevelopment) {
    if (outputPath && outputUsed) {
      outputPath = path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.min.js');
    } else if (!outputPath) {
      outputPath = path.join(cwd, basename + '.min.js');
    }
    minify(source, {
      'filePath': filePath,
      'isMapped': isMapped,
      'isSilent': isSilent,
      'isTemplate': isTemplate,
      'modes': isIIFE ? ['simple', 'hybrid'] : ['simple', 'advanced', 'hybrid'],
      'outputPath': outputPath,
      'sourceMapURL': sourceMapURL,
      'onComplete': function(data) {
        if (isCustom) {
          data.source = addCommandsToHeader(data.source, options);
        }
        if (isStdOut) {
          delete data.outputPath;
          stdout.write(data.source);
        }
        callback(data);
      }
    });
  }
}

/*----------------------------------------------------------------------------*/

// Export `build`.
if (!isBin) {
  module.exports = build;
}
// Handle invoking `build` by the command-line.
else if (_.size(process.argv) > 2) {
  build(process.argv.slice(2));
}
